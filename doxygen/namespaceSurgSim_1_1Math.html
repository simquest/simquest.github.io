<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>OpenSurgSim: SurgSim::Math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 90px;">
  <td id="projectlogo">
     <img alt="OpenSurgSim: A free platform for open surgery simulation" src="OpenSurgSim-dox.png"/>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSurgSim.html">SurgSim</a></li><li class="navelem"><a class="el" href="namespaceSurgSim_1_1Math.html">Math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SurgSim::Math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSurgSim_1_1Math_1_1Geometry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math_1_1Geometry.html">Geometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1BoxShape.html">BoxShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Box shape: box centered on (0 0 0), aligned with the axis with different sizes along X, Y and Z.  <a href="classSurgSim_1_1Math_1_1BoxShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1CapsuleShape.html">CapsuleShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capsule shape: centered on (0, 0, 0), aligned along Y, with length and radius.  <a href="classSurgSim_1_1Math_1_1CapsuleShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1CylinderShape.html">CylinderShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cylinder shape: centered on (0 0 0), aligned along Y, defined with length and radius.  <a href="classSurgSim_1_1Math_1_1CylinderShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1DoubleSidedPlaneShape.html">DoubleSidedPlaneShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSurgSim_1_1Math_1_1DoubleSidedPlaneShape.html" title="DoubleSidedPlaneShape: The XZ plane (d = 0) with normal pointing along positive Y axis...">DoubleSidedPlaneShape</a>: The XZ plane (d = 0) with normal pointing along positive Y axis.  <a href="classSurgSim_1_1Math_1_1DoubleSidedPlaneShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1LinearSolveAndInverse.html">LinearSolveAndInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSurgSim_1_1Math_1_1LinearSolveAndInverse.html" title="LinearSolveAndInverse aims at performing an efficient linear system resolution and calculating its in...">LinearSolveAndInverse</a> aims at performing an efficient linear system resolution and calculating its inverse matrix at the same time.  <a href="classSurgSim_1_1Math_1_1LinearSolveAndInverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1LinearSolveAndInverseDenseMatrix.html">LinearSolveAndInverseDenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivation for dense matrix type.  <a href="classSurgSim_1_1Math_1_1LinearSolveAndInverseDenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1LinearSolveAndInverseDiagonalMatrix.html">LinearSolveAndInverseDiagonalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivation for diagonal matrix type.  <a href="classSurgSim_1_1Math_1_1LinearSolveAndInverseDiagonalMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1LinearSolveAndInverseSymmetricTriDiagonalBlockMatrix.html">LinearSolveAndInverseSymmetricTriDiagonalBlockMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivation for symmetric tri-diagonal block matrix type.  <a href="classSurgSim_1_1Math_1_1LinearSolveAndInverseSymmetricTriDiagonalBlockMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1LinearSolveAndInverseTriDiagonalBlockMatrix.html">LinearSolveAndInverseTriDiagonalBlockMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivation for tri-diagonal block matrix type.  <a href="classSurgSim_1_1Math_1_1LinearSolveAndInverseTriDiagonalBlockMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1MeshShape.html">MeshShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh shape: shape made of a triangle mesh The triangle mesh needs to be watertight to produce valid volume, center and second moment of volume.  <a href="classSurgSim_1_1Math_1_1MeshShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1MlcpGaussSeidelSolver.html">MlcpGaussSeidelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A solver for mixed LCP problems using the Gauss-Seidel iterative method.  <a href="classSurgSim_1_1Math_1_1MlcpGaussSeidelSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSurgSim_1_1Math_1_1MlcpProblem.html">MlcpProblem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of an MLCP (mixed linear complementarity problem, or mixed LCP) system to be solved.  <a href="structSurgSim_1_1Math_1_1MlcpProblem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSurgSim_1_1Math_1_1MlcpSolution.html">MlcpSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The description of a solution to a <a class="el" href="structSurgSim_1_1Math_1_1MlcpProblem.html">mixed linear complementarity problem</a>.  <a href="structSurgSim_1_1Math_1_1MlcpSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1MlcpSolver.html">MlcpSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a solver interface for mixed linear complementarity problems.  <a href="classSurgSim_1_1Math_1_1MlcpSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OctreeShape.html">OctreeShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Octree <a class="el" href="classSurgSim_1_1Math_1_1Shape.html" title="Generic rigid shape class defining a shape. ">Shape</a> A defined by an octree data structure.  <a href="classSurgSim_1_1Math_1_1OctreeShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeEquation.html">OdeEquation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ode equation of 2nd order of the form M(x,v).a = F(x, v) with (x0, v0) for initial conditions and a set of boundary conditions.  <a href="classSurgSim_1_1Math_1_1OdeEquation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolver.html">OdeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all solvers of ode equation of order 2 of the form M(x(t), v(t)).a(t) = f(t, x(t), v(t))  <a href="classSurgSim_1_1Math_1_1OdeSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverEulerExplicit.html">OdeSolverEulerExplicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euler Explicit ode solver.  <a href="classSurgSim_1_1Math_1_1OdeSolverEulerExplicit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverEulerExplicitModified.html">OdeSolverEulerExplicitModified</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euler Explicit Modified ode solver.  <a href="classSurgSim_1_1Math_1_1OdeSolverEulerExplicitModified.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverEulerImplicit.html">OdeSolverEulerImplicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euler Implicit ode solver.  <a href="classSurgSim_1_1Math_1_1OdeSolverEulerImplicit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverLinearEulerExplicit.html">OdeSolverLinearEulerExplicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear Version of the Euler Explicit ode solver This solver assumes that the system is linear, ie that Mass, Damping, and Stiffness matrices do not change.  <a href="classSurgSim_1_1Math_1_1OdeSolverLinearEulerExplicit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverLinearEulerExplicitModified.html">OdeSolverLinearEulerExplicitModified</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear Version of the Modified Euler Explicit ode solver This solver assumes that the system is linear, ie that Mass, Damping, and Stiffness matrices do not change.  <a href="classSurgSim_1_1Math_1_1OdeSolverLinearEulerExplicitModified.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverLinearEulerImplicit.html">OdeSolverLinearEulerImplicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear Version of the Euler Implicit ode solver This solver assumes that the system is linear, ie that Mass, Damping, and Stiffness matrices do not change.  <a href="classSurgSim_1_1Math_1_1OdeSolverLinearEulerImplicit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverLinearRungeKutta4.html">OdeSolverLinearRungeKutta4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear Version of the Runge Kutta 4 ode solver This solver assumes that the system is linear ie that Mass, Damping, and Stiffness matrices do not change.  <a href="classSurgSim_1_1Math_1_1OdeSolverLinearRungeKutta4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverLinearStatic.html">OdeSolverLinearStatic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear version of the static ode solver This solver assumes that the system is linear, ie that Stiffness matrix does not change.  <a href="classSurgSim_1_1Math_1_1OdeSolverLinearStatic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverRungeKutta4.html">OdeSolverRungeKutta4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runge Kutta 4 ode solver See <a href="http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods</a>.  <a href="classSurgSim_1_1Math_1_1OdeSolverRungeKutta4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeSolverStatic.html">OdeSolverStatic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static ode solver.  <a href="classSurgSim_1_1Math_1_1OdeSolverStatic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1OdeState.html">OdeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSurgSim_1_1Math_1_1OdeState.html" title="OdeState defines the state y of an ode of 2nd order of the form M(x,v).a = F(x, v) with boundary cond...">OdeState</a> defines the state y of an ode of 2nd order of the form M(x,v).a = F(x, v) with boundary conditions.  <a href="classSurgSim_1_1Math_1_1OdeState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1PlaneShape.html">PlaneShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The XZ plane (d = 0) with normal pointing along positive Y axis.  <a href="classSurgSim_1_1Math_1_1PlaneShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic rigid shape class defining a shape.  <a href="classSurgSim_1_1Math_1_1Shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1SphereShape.html">SphereShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere shape: sphere centered on (0 0 0), defined with radius.  <a href="classSurgSim_1_1Math_1_1SphereShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1SurfaceMeshShape.html">SurfaceMeshShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSurgSim_1_1Math_1_1SurfaceMeshShape.html" title="SurfaceMeshShape defines a shape based on a mesh, like MeshShape. ">SurfaceMeshShape</a> defines a shape based on a mesh, like <a class="el" href="classSurgSim_1_1Math_1_1MeshShape.html" title="Mesh shape: shape made of a triangle mesh The triangle mesh needs to be watertight to produce valid v...">MeshShape</a>.  <a href="classSurgSim_1_1Math_1_1SurfaceMeshShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSurgSim_1_1Math_1_1TriangleHelper.html">TriangleHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for a triangle, used for the following two purposes:  <a href="classSurgSim_1_1Math_1_1TriangleHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a98699f544aaca521aadf2b9aaac42e8f"><td class="memItemLeft" align="right" valign="top">typedef Eigen::AlignedBox<br class="typebreak" />
&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a98699f544aaca521aadf2b9aaac42e8f">Aabbf</a></td></tr>
<tr class="memdesc:a98699f544aaca521aadf2b9aaac42e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around the <a class="el" href="namespaceEigen.html">Eigen</a> type.  <a href="#a98699f544aaca521aadf2b9aaac42e8f">More...</a><br /></td></tr>
<tr class="separator:a98699f544aaca521aadf2b9aaac42e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c5daa850a324fbfc23a003043879bc"><td class="memItemLeft" align="right" valign="top">typedef Eigen::AlignedBox<br class="typebreak" />
&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a46c5daa850a324fbfc23a003043879bc">Aabbd</a></td></tr>
<tr class="memdesc:a46c5daa850a324fbfc23a003043879bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around the <a class="el" href="namespaceEigen.html">Eigen</a> type.  <a href="#a46c5daa850a324fbfc23a003043879bc">More...</a><br /></td></tr>
<tr class="separator:a46c5daa850a324fbfc23a003043879bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaed4c38a810334c3426810a901941c4"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, <br class="typebreak" />
2, 2, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#afaed4c38a810334c3426810a901941c4">Matrix22f</a></td></tr>
<tr class="memdesc:afaed4c38a810334c3426810a901941c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix of floats.  <a href="#afaed4c38a810334c3426810a901941c4">More...</a><br /></td></tr>
<tr class="separator:afaed4c38a810334c3426810a901941c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182881b84e0a2b0caa7f2fc59490a11f"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, <br class="typebreak" />
3, 3, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a182881b84e0a2b0caa7f2fc59490a11f">Matrix33f</a></td></tr>
<tr class="memdesc:a182881b84e0a2b0caa7f2fc59490a11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix of floats.  <a href="#a182881b84e0a2b0caa7f2fc59490a11f">More...</a><br /></td></tr>
<tr class="separator:a182881b84e0a2b0caa7f2fc59490a11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3265d7be70bc60e14022333382ebd2"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, <br class="typebreak" />
4, 4, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a3d3265d7be70bc60e14022333382ebd2">Matrix44f</a></td></tr>
<tr class="memdesc:a3d3265d7be70bc60e14022333382ebd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix of floats.  <a href="#a3d3265d7be70bc60e14022333382ebd2">More...</a><br /></td></tr>
<tr class="separator:a3d3265d7be70bc60e14022333382ebd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a9633eeb333f594a0303d6e114e4a"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak" />
2, 2, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a1a0a9633eeb333f594a0303d6e114e4a">Matrix22d</a></td></tr>
<tr class="memdesc:a1a0a9633eeb333f594a0303d6e114e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix of doubles.  <a href="#a1a0a9633eeb333f594a0303d6e114e4a">More...</a><br /></td></tr>
<tr class="separator:a1a0a9633eeb333f594a0303d6e114e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e759a037e742d33d39c187a047e98d"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak" />
3, 3, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#af7e759a037e742d33d39c187a047e98d">Matrix33d</a></td></tr>
<tr class="memdesc:af7e759a037e742d33d39c187a047e98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix of doubles.  <a href="#af7e759a037e742d33d39c187a047e98d">More...</a><br /></td></tr>
<tr class="separator:af7e759a037e742d33d39c187a047e98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff80c35c6bee7833ddcf6ab5cbc6384f"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak" />
4, 4, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aff80c35c6bee7833ddcf6ab5cbc6384f">Matrix44d</a></td></tr>
<tr class="memdesc:aff80c35c6bee7833ddcf6ab5cbc6384f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix of doubles.  <a href="#aff80c35c6bee7833ddcf6ab5cbc6384f">More...</a><br /></td></tr>
<tr class="separator:aff80c35c6bee7833ddcf6ab5cbc6384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a698014f73410555fb4b7826a3e0419"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak" />
6, 6, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a5a698014f73410555fb4b7826a3e0419">Matrix66d</a></td></tr>
<tr class="memdesc:a5a698014f73410555fb4b7826a3e0419"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 6x6 matrix of doubles.  <a href="#a5a698014f73410555fb4b7826a3e0419">More...</a><br /></td></tr>
<tr class="separator:a5a698014f73410555fb4b7826a3e0419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e6600f6851d0ce2b751e6732de6325"><td class="memItemLeft" align="right" valign="top">typedef Eigen::DiagonalMatrix<br class="typebreak" />
&lt; double, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ad5e6600f6851d0ce2b751e6732de6325">DiagonalMatrix</a></td></tr>
<tr class="memdesc:ad5e6600f6851d0ce2b751e6732de6325"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic size diagonal matrix.  <a href="#ad5e6600f6851d0ce2b751e6732de6325">More...</a><br /></td></tr>
<tr class="separator:ad5e6600f6851d0ce2b751e6732de6325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09630a3dd9bc5c78f9a68a313e4582ab"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak" />
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a09630a3dd9bc5c78f9a68a313e4582ab">Matrix</a></td></tr>
<tr class="memdesc:a09630a3dd9bc5c78f9a68a313e4582ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic size matrix.  <a href="#a09630a3dd9bc5c78f9a68a313e4582ab">More...</a><br /></td></tr>
<tr class="separator:a09630a3dd9bc5c78f9a68a313e4582ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d585e90e738cb258d51902492be521"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Quaternion&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ac8d585e90e738cb258d51902492be521">Quaternionf</a></td></tr>
<tr class="memdesc:ac8d585e90e738cb258d51902492be521"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quaternion of floats.  <a href="#ac8d585e90e738cb258d51902492be521">More...</a><br /></td></tr>
<tr class="separator:ac8d585e90e738cb258d51902492be521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8deb517a88b1991f65d786ffc4b7a1d8"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Quaternion&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a8deb517a88b1991f65d786ffc4b7a1d8">Quaterniond</a></td></tr>
<tr class="memdesc:a8deb517a88b1991f65d786ffc4b7a1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quaternion of doubles.  <a href="#a8deb517a88b1991f65d786ffc4b7a1d8">More...</a><br /></td></tr>
<tr class="separator:a8deb517a88b1991f65d786ffc4b7a1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b4e059748b22e737077e421a6eefa5"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Transform<br class="typebreak" />
&lt; float, 2, Eigen::Isometry &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a78b4e059748b22e737077e421a6eefa5">RigidTransform2f</a></td></tr>
<tr class="memdesc:a78b4e059748b22e737077e421a6eefa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D rigid (isometric) transform, represented as floats.  <a href="#a78b4e059748b22e737077e421a6eefa5">More...</a><br /></td></tr>
<tr class="separator:a78b4e059748b22e737077e421a6eefa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a94492b43148dcbe1367ed5a8db18c1"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Transform<br class="typebreak" />
&lt; float, 3, Eigen::Isometry &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a6a94492b43148dcbe1367ed5a8db18c1">RigidTransform3f</a></td></tr>
<tr class="memdesc:a6a94492b43148dcbe1367ed5a8db18c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D rigid (isometric) transform, represented as floats.  <a href="#a6a94492b43148dcbe1367ed5a8db18c1">More...</a><br /></td></tr>
<tr class="separator:a6a94492b43148dcbe1367ed5a8db18c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614d9cdc331250878cd7c6409bacb06d"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Transform<br class="typebreak" />
&lt; double, 2, Eigen::Isometry &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a614d9cdc331250878cd7c6409bacb06d">RigidTransform2d</a></td></tr>
<tr class="memdesc:a614d9cdc331250878cd7c6409bacb06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D rigid (isometric) transform, represented as doubles.  <a href="#a614d9cdc331250878cd7c6409bacb06d">More...</a><br /></td></tr>
<tr class="separator:a614d9cdc331250878cd7c6409bacb06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5702b833ce6119c68ad5e014144217a"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Transform<br class="typebreak" />
&lt; double, 3, Eigen::Isometry &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ab5702b833ce6119c68ad5e014144217a">RigidTransform3d</a></td></tr>
<tr class="memdesc:ab5702b833ce6119c68ad5e014144217a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D rigid (isometric) transform, represented as doubles.  <a href="#ab5702b833ce6119c68ad5e014144217a">More...</a><br /></td></tr>
<tr class="separator:ab5702b833ce6119c68ad5e014144217a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81114e23eb642de3f621c04b3ac02faa"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, 2, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a81114e23eb642de3f621c04b3ac02faa">Vector2f</a></td></tr>
<tr class="memdesc:a81114e23eb642de3f621c04b3ac02faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D vector of floats.  <a href="#a81114e23eb642de3f621c04b3ac02faa">More...</a><br /></td></tr>
<tr class="separator:a81114e23eb642de3f621c04b3ac02faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9ff4319e35f1e6a42b46a3c07b07ed"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#afa9ff4319e35f1e6a42b46a3c07b07ed">Vector3f</a></td></tr>
<tr class="memdesc:afa9ff4319e35f1e6a42b46a3c07b07ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D vector of floats.  <a href="#afa9ff4319e35f1e6a42b46a3c07b07ed">More...</a><br /></td></tr>
<tr class="separator:afa9ff4319e35f1e6a42b46a3c07b07ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692cb10c56f5da2368712efd498d5caa"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a692cb10c56f5da2368712efd498d5caa">Vector4f</a></td></tr>
<tr class="memdesc:a692cb10c56f5da2368712efd498d5caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4D vector of floats.  <a href="#a692cb10c56f5da2368712efd498d5caa">More...</a><br /></td></tr>
<tr class="separator:a692cb10c56f5da2368712efd498d5caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9219b6491829f484eaa69bbb0cfa5e"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; float, 6, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a1e9219b6491829f484eaa69bbb0cfa5e">Vector6f</a></td></tr>
<tr class="memdesc:a1e9219b6491829f484eaa69bbb0cfa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 6D vector of floats.  <a href="#a1e9219b6491829f484eaa69bbb0cfa5e">More...</a><br /></td></tr>
<tr class="separator:a1e9219b6491829f484eaa69bbb0cfa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa132b3b1bf6eab903c1842e8cd2024"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, 2, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a4aa132b3b1bf6eab903c1842e8cd2024">Vector2d</a></td></tr>
<tr class="memdesc:a4aa132b3b1bf6eab903c1842e8cd2024"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D vector of doubles.  <a href="#a4aa132b3b1bf6eab903c1842e8cd2024">More...</a><br /></td></tr>
<tr class="separator:a4aa132b3b1bf6eab903c1842e8cd2024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae052fe9c89b6abb1dc047ed830ef35"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a4ae052fe9c89b6abb1dc047ed830ef35">Vector3d</a></td></tr>
<tr class="memdesc:a4ae052fe9c89b6abb1dc047ed830ef35"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D vector of doubles.  <a href="#a4ae052fe9c89b6abb1dc047ed830ef35">More...</a><br /></td></tr>
<tr class="separator:a4ae052fe9c89b6abb1dc047ed830ef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74b1307bea307b4356af0e96721a9e2"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ad74b1307bea307b4356af0e96721a9e2">Vector4d</a></td></tr>
<tr class="memdesc:ad74b1307bea307b4356af0e96721a9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4D vector of doubles.  <a href="#ad74b1307bea307b4356af0e96721a9e2">More...</a><br /></td></tr>
<tr class="separator:ad74b1307bea307b4356af0e96721a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cd0db17727d3f7dbeea479aecf9b2e"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, 6, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a52cd0db17727d3f7dbeea479aecf9b2e">Vector6d</a></td></tr>
<tr class="memdesc:a52cd0db17727d3f7dbeea479aecf9b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 6D matrix of doubles.  <a href="#a52cd0db17727d3f7dbeea479aecf9b2e">More...</a><br /></td></tr>
<tr class="separator:a52cd0db17727d3f7dbeea479aecf9b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bac671a4eb2e7e762ac8b836e941a7"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak" />
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">Vector</a></td></tr>
<tr class="memdesc:ad0bac671a4eb2e7e762ac8b836e941a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic size column vector.  <a href="#ad0bac671a4eb2e7e762ac8b836e941a7">More...</a><br /></td></tr>
<tr class="separator:ad0bac671a4eb2e7e762ac8b836e941a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a76863af6f5e08e63c418a070ecb7e844"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844">MlcpConstraintType</a> { <br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844ac2bbb7a57ed35297239882c88fa9a311">MLCP_INVALID_CONSTRAINT</a> = -1, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844a5462335804811ec4e30d263eb62276a2">MLCP_BILATERAL_1D_CONSTRAINT</a> = 0, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844ad30ae3e813b205623676f6419b78d1b0">MLCP_BILATERAL_2D_CONSTRAINT</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844aff8510545b979ae36ff505a17a81275a">MLCP_BILATERAL_3D_CONSTRAINT</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844ab04116b46bb643cf13ba701321ebbbeb">MLCP_UNILATERAL_3D_FRICTIONLESS_CONSTRAINT</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844abd27e398840d299ad094f35c99a5339b">MLCP_UNILATERAL_3D_FRICTIONAL_CONSTRAINT</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844a7a889c9d3890b1934a2a0ff61aed4d9d">MLCP_BILATERAL_FRICTIONLESS_SLIDING_CONSTRAINT</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844a477fb71022bc3f65f39fb42d6e193ce6">MLCP_BILATERAL_FRICTIONAL_SLIDING_CONSTRAINT</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844a31beb6be0fc5dec3b79639a7fa5ce1c3">MLCP_NUM_CONSTRAINT_TYPES</a>
<br />
 }</td></tr>
<tr class="separator:a76863af6f5e08e63c418a070ecb7e844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9658a7cc17cc4b6f3d8accf2a8070125"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125">IntegrationScheme</a> { <br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125a6edc630aa3769d421af13c101c51a50f">INTEGRATIONSCHEME_STATIC</a> = 0, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125abe1e7fef146cc2287a993a19e3ca32a9">INTEGRATIONSCHEME_LINEAR_STATIC</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125a998867da87fd8a2ffc652433a8f7a1b8">INTEGRATIONSCHEME_EXPLICIT_EULER</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125a5c2bb6413a30c198449d8df0633eed5a">INTEGRATIONSCHEME_LINEAR_EXPLICIT_EULER</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125a1ed293a0fed9d092b99c54950609906e">INTEGRATIONSCHEME_MODIFIED_EXPLICIT_EULER</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125afeb6fc8d45cd54031dff437471249b2e">INTEGRATIONSCHEME_LINEAR_MODIFIED_EXPLICIT_EULER</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125ae740042b3568364f8c0eb641e2ddc242">INTEGRATIONSCHEME_IMPLICIT_EULER</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125a924238ecbed25e98bd10d72e2a152d15">INTEGRATIONSCHEME_LINEAR_IMPLICIT_EULER</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125a462a3cbe5c697b43bc6e9cd66e637970">INTEGRATIONSCHEME_RUNGE_KUTTA_4</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125ab75f33aeff7a99ccb3ed30b5a9c4bd95">INTEGRATIONSCHEME_LINEAR_RUNGE_KUTTA_4</a>
<br />
 }</td></tr>
<tr class="memdesc:a9658a7cc17cc4b6f3d8accf2a8070125"><td class="mdescLeft">&#160;</td><td class="mdescRight">The diverse numerical integration scheme supported Each Ode Solver should have its own entry in this enum.  <a href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125">More...</a><br /></td></tr>
<tr class="separator:a9658a7cc17cc4b6f3d8accf2a8070125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411443fa5506f17c068f9ce5f3132fb3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a411443fa5506f17c068f9ce5f3132fb3">ShapeDirection</a> { <a class="el" href="namespaceSurgSim_1_1Math.html#a411443fa5506f17c068f9ce5f3132fb3a2b10edc494ea49d04d0edd4deec77072">SHAPE_DIRECTION_AXIS_X</a> = 0, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a411443fa5506f17c068f9ce5f3132fb3a06a3ea0b7f95031b99ffcdf5e84fd1c6">SHAPE_DIRECTION_AXIS_Y</a> = 1, 
<a class="el" href="namespaceSurgSim_1_1Math.html#a411443fa5506f17c068f9ce5f3132fb3a1af4c5ca53d9e606007edfee409d0e89">SHAPE_DIRECTION_AXIS_Z</a> = 2
 }</td></tr>
<tr class="memdesc:a411443fa5506f17c068f9ce5f3132fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type defining the shape direction for certain templatized shape (i.e.  <a href="namespaceSurgSim_1_1Math.html#a411443fa5506f17c068f9ce5f3132fb3">More...</a><br /></td></tr>
<tr class="separator:a411443fa5506f17c068f9ce5f3132fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1cfcc0a19a1ab8b923ff8fa41b437"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437">ShapeType</a> { <br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437ac4b909b9a4baa382f82170a51b863ced">SHAPE_TYPE_NONE</a> = -1, 
<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437a2bbc57f3ac6e6c62fd741de261b0cba1">SHAPE_TYPE_BOX</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437a2f758b697b57c7dbddb6c72a120dc2eb">SHAPE_TYPE_CAPSULE</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437a2fb5ac94bea29ac1db26744158c2a025">SHAPE_TYPE_CYLINDER</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437a1176c995ee30f77a67e05b649512d52c">SHAPE_TYPE_DOUBLESIDEDPLANE</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437aba359609fcbf6afa38184ebc1de41249">SHAPE_TYPE_MESH</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437a0b40cff2368a2c81ca0c82a3b1185ce2">SHAPE_TYPE_OCTREE</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437a01fb91151e39549aa233e8369220fca1">SHAPE_TYPE_PLANE</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437ab976c25d1c304070d01ca73e6df2a04d">SHAPE_TYPE_SPHERE</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437aada0b15e3aef6bfd2b7ab01337a69a31">SHAPE_TYPE_SURFACEMESH</a>, 
<a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437afe83ee1344ac061d09b6714e23e1937d">SHAPE_TYPE_COUNT</a>
<br />
 }</td></tr>
<tr class="memdesc:aaae1cfcc0a19a1ab8b923ff8fa41b437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed List of enums for the available Shape types, do not explicitly assign values, ShapeCount is used to determine the number of actual shape types.  <a href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437">More...</a><br /></td></tr>
<tr class="separator:aaae1cfcc0a19a1ab8b923ff8fa41b437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac70085ba6ead5d388aa603ee30e02f53"><td class="memTemplParams" colspan="2">template&lt;class Scalar , int Dim&gt; </td></tr>
<tr class="memitem:ac70085ba6ead5d388aa603ee30e02f53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ac70085ba6ead5d388aa603ee30e02f53">doAabbIntersect</a> (const Eigen::AlignedBox&lt; Scalar, Dim &gt; &amp;aabb0, const Eigen::AlignedBox&lt; Scalar, Dim &gt; &amp;aabb1, double tolerance)</td></tr>
<tr class="memdesc:ac70085ba6ead5d388aa603ee30e02f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two AABBs have an intersection with each other, for the calculation see <a href="http://www.gamasutra.com/view/feature/131790/simple_intersection_tests_for_games.php?page=3">http://www.gamasutra.com/view/feature/131790/simple_intersection_tests_for_games.php?page=3</a>.  <a href="#ac70085ba6ead5d388aa603ee30e02f53">More...</a><br /></td></tr>
<tr class="separator:ac70085ba6ead5d388aa603ee30e02f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6485f8667bd89df354e65ba872970d1"><td class="memTemplParams" colspan="2">template&lt;class Scalar , int Dim&gt; </td></tr>
<tr class="memitem:af6485f8667bd89df354e65ba872970d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#af6485f8667bd89df354e65ba872970d1">doAabbIntersect</a> (const Eigen::AlignedBox&lt; Scalar, Dim &gt; &amp;a, const Eigen::AlignedBox&lt; Scalar, Dim &gt; &amp;b)</td></tr>
<tr class="memdesc:af6485f8667bd89df354e65ba872970d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two AABBs overlap, using a minimal set of eigen calls, does not take a tolerance.  <a href="#af6485f8667bd89df354e65ba872970d1">More...</a><br /></td></tr>
<tr class="separator:af6485f8667bd89df354e65ba872970d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1c2267da36b307694eb8a10f460799"><td class="memTemplParams" colspan="2">template&lt;class Scalar , int Dim, int MType&gt; </td></tr>
<tr class="memitem:a8e1c2267da36b307694eb8a10f460799"><td class="memTemplItemLeft" align="right" valign="top">Eigen::AlignedBox&lt; Scalar, Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a8e1c2267da36b307694eb8a10f460799">makeAabb</a> (const Eigen::Matrix&lt; Scalar, Dim, 1, MType &gt; &amp;vector0, const Eigen::Matrix&lt; Scalar, Dim, 1, MType &gt; &amp;vector1, const Eigen::Matrix&lt; Scalar, Dim, 1, MType &gt; &amp;vector2)</td></tr>
<tr class="memdesc:a8e1c2267da36b307694eb8a10f460799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for creating a bounding box from three vertices (e.g.  <a href="#a8e1c2267da36b307694eb8a10f460799">More...</a><br /></td></tr>
<tr class="separator:a8e1c2267da36b307694eb8a10f460799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb6b7bb61aa50da1799b50e72e361ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a5cb6b7bb61aa50da1799b50e72e361ed">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1BoxShape.html">SurgSim::Math::BoxShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1BoxShape.html">BoxShape</a>)</td></tr>
<tr class="separator:a5cb6b7bb61aa50da1799b50e72e361ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeced1b545d8bd65f3dba869641109e90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aeced1b545d8bd65f3dba869641109e90">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1BoxShape.html">BoxShape</a>)</td></tr>
<tr class="separator:aeced1b545d8bd65f3dba869641109e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d680aa0e22a9f2dd091c22aacff5b43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a2d680aa0e22a9f2dd091c22aacff5b43">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1CapsuleShape.html">SurgSim::Math::CapsuleShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1CapsuleShape.html">CapsuleShape</a>)</td></tr>
<tr class="separator:a2d680aa0e22a9f2dd091c22aacff5b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0339ae4326311b32debaf24e4cc83d16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a0339ae4326311b32debaf24e4cc83d16">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1CapsuleShape.html">CapsuleShape</a>)</td></tr>
<tr class="separator:a0339ae4326311b32debaf24e4cc83d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac29757a5e84f10843be7c6dea0f3b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#abac29757a5e84f10843be7c6dea0f3b1">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1CylinderShape.html">SurgSim::Math::CylinderShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1CylinderShape.html">CylinderShape</a>)</td></tr>
<tr class="separator:abac29757a5e84f10843be7c6dea0f3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ca30c9560a55f658f45f723c9b18d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ad2ca30c9560a55f658f45f723c9b18d6">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1CylinderShape.html">CylinderShape</a>)</td></tr>
<tr class="separator:ad2ca30c9560a55f658f45f723c9b18d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485c28dda48813b25912d404247fc9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a5485c28dda48813b25912d404247fc9f">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1DoubleSidedPlaneShape.html">SurgSim::Math::DoubleSidedPlaneShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1DoubleSidedPlaneShape.html">DoubleSidedPlaneShape</a>)</td></tr>
<tr class="separator:a5485c28dda48813b25912d404247fc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e0fca2577ee1b6624f5f0d1f535ef7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a56e0fca2577ee1b6624f5f0d1f535ef7">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1DoubleSidedPlaneShape.html">DoubleSidedPlaneShape</a>)</td></tr>
<tr class="separator:a56e0fca2577ee1b6624f5f0d1f535ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa04ec545252017ab2d3e4a1e8409dcf"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:aaa04ec545252017ab2d3e4a1e8409dcf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aaa04ec545252017ab2d3e4a1e8409dcf">barycentricCoordinates</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pt, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tn, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *coordinates)</td></tr>
<tr class="memdesc:aaa04ec545252017ab2d3e4a1e8409dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the barycentric coordinates of a point with respect to a triangle.  <a href="#aaa04ec545252017ab2d3e4a1e8409dcf">More...</a><br /></td></tr>
<tr class="separator:aaa04ec545252017ab2d3e4a1e8409dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0706fbe5ed3468facd6ccd16286bf787"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a0706fbe5ed3468facd6ccd16286bf787"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a0706fbe5ed3468facd6ccd16286bf787">barycentricCoordinates</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pt, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *coordinates)</td></tr>
<tr class="memdesc:a0706fbe5ed3468facd6ccd16286bf787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the barycentric coordinates of a point with respect to a triangle.  <a href="#a0706fbe5ed3468facd6ccd16286bf787">More...</a><br /></td></tr>
<tr class="separator:a0706fbe5ed3468facd6ccd16286bf787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb197b6c0c0f9605be3cf86c12d9d1"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:ae0cb197b6c0c0f9605be3cf86c12d9d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ae0cb197b6c0c0f9605be3cf86c12d9d1">isPointInsideTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pt, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tn)</td></tr>
<tr class="memdesc:ae0cb197b6c0c0f9605be3cf86c12d9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is inside a triangle.  <a href="#ae0cb197b6c0c0f9605be3cf86c12d9d1">More...</a><br /></td></tr>
<tr class="separator:ae0cb197b6c0c0f9605be3cf86c12d9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84c69f2f8a08233f9fe9df2efa10f2c"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:af84c69f2f8a08233f9fe9df2efa10f2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#af84c69f2f8a08233f9fe9df2efa10f2c">isPointInsideTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pt, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2)</td></tr>
<tr class="memdesc:af84c69f2f8a08233f9fe9df2efa10f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point is inside a triangle.  <a href="#af84c69f2f8a08233f9fe9df2efa10f2c">More...</a><br /></td></tr>
<tr class="separator:af84c69f2f8a08233f9fe9df2efa10f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482bca6dd2b244858c10c4dbd053b549"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a482bca6dd2b244858c10c4dbd053b549"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a482bca6dd2b244858c10c4dbd053b549">isCoplanar</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;a, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;b, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;c, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;d)</td></tr>
<tr class="memdesc:a482bca6dd2b244858c10c4dbd053b549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the points are coplanar.  <a href="#a482bca6dd2b244858c10c4dbd053b549">More...</a><br /></td></tr>
<tr class="separator:a482bca6dd2b244858c10c4dbd053b549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e2a98a94db7ce8e9c84e196bae35fd"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:af8e2a98a94db7ce8e9c84e196bae35fd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#af8e2a98a94db7ce8e9c84e196bae35fd">distancePointLine</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pt, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;v1, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *result)</td></tr>
<tr class="memdesc:af8e2a98a94db7ce8e9c84e196bae35fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the normal distance between a point and a line.  <a href="#af8e2a98a94db7ce8e9c84e196bae35fd">More...</a><br /></td></tr>
<tr class="separator:af8e2a98a94db7ce8e9c84e196bae35fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35475dc04729dbe1fb485df92a29866e"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a35475dc04729dbe1fb485df92a29866e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a35475dc04729dbe1fb485df92a29866e">distancePointSegment</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pt, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv1, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *result)</td></tr>
<tr class="memdesc:a35475dc04729dbe1fb485df92a29866e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point segment distance, if the projection of the closest point is not within the segments, the closest segment point is used for the distance calculation.  <a href="#a35475dc04729dbe1fb485df92a29866e">More...</a><br /></td></tr>
<tr class="separator:a35475dc04729dbe1fb485df92a29866e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d6115addb1846b588e6f9d28ad30d6"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a50d6115addb1846b588e6f9d28ad30d6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a50d6115addb1846b588e6f9d28ad30d6">distanceLineLine</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;l0v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;l0v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;l1v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;l1v1, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *pt0, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *pt1)</td></tr>
<tr class="memdesc:a50d6115addb1846b588e6f9d28ad30d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the distance between two lines.  <a href="#a50d6115addb1846b588e6f9d28ad30d6">More...</a><br /></td></tr>
<tr class="separator:a50d6115addb1846b588e6f9d28ad30d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cd05c651b56d43baaeb5aaa488698f"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a00cd05c651b56d43baaeb5aaa488698f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a00cd05c651b56d43baaeb5aaa488698f">distanceSegmentSegment</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;s0v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;s0v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;s1v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;s1v1, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *pt0, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *pt1, T *s0t=nullptr, T *s1t=nullptr)</td></tr>
<tr class="memdesc:a00cd05c651b56d43baaeb5aaa488698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance between two segments, if the project of the closest point is not on the opposing segment, the segment endpoints will be used for the distance calculation.  <a href="#a00cd05c651b56d43baaeb5aaa488698f">More...</a><br /></td></tr>
<tr class="separator:a00cd05c651b56d43baaeb5aaa488698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf836d6fcf8a0d8b572c162de1cb1358"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:adf836d6fcf8a0d8b572c162de1cb1358"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#adf836d6fcf8a0d8b572c162de1cb1358">distancePointTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pt, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *result)</td></tr>
<tr class="memdesc:adf836d6fcf8a0d8b572c162de1cb1358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the normal distance of a point from a triangle, the resulting point will be on the edge of the triangle if the projection of the point is not inside the triangle.  <a href="#adf836d6fcf8a0d8b572c162de1cb1358">More...</a><br /></td></tr>
<tr class="separator:adf836d6fcf8a0d8b572c162de1cb1358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3350b166fcff3495bcd97a04a22873a"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:ad3350b166fcff3495bcd97a04a22873a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ad3350b166fcff3495bcd97a04a22873a">doesCollideSegmentTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tn, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *result)</td></tr>
<tr class="memdesc:ad3350b166fcff3495bcd97a04a22873a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the intersection of a line segment with a triangle See <a href="http://geomalgorithms.com/a06-_intersect-2.html#intersect_RayTriangle">http://geomalgorithms.com/a06-_intersect-2.html#intersect_RayTriangle</a> for the algorithm.  <a href="#ad3350b166fcff3495bcd97a04a22873a">More...</a><br /></td></tr>
<tr class="separator:ad3350b166fcff3495bcd97a04a22873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63337c2b76e510312f48c8cf2b671bbd"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a63337c2b76e510312f48c8cf2b671bbd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a63337c2b76e510312f48c8cf2b671bbd">distancePointPlane</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pt, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;n, T d, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *result)</td></tr>
<tr class="memdesc:a63337c2b76e510312f48c8cf2b671bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance of a point to a plane.  <a href="#a63337c2b76e510312f48c8cf2b671bbd">More...</a><br /></td></tr>
<tr class="separator:a63337c2b76e510312f48c8cf2b671bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2635a405b157e933c75c7801037a1635"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a2635a405b157e933c75c7801037a1635"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a2635a405b157e933c75c7801037a1635">distanceSegmentPlane</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;n, T d, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *closestPointSegment, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *planeIntersectionPoint)</td></tr>
<tr class="memdesc:a2635a405b157e933c75c7801037a1635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between a segment and a plane.  <a href="#a2635a405b157e933c75c7801037a1635">More...</a><br /></td></tr>
<tr class="separator:a2635a405b157e933c75c7801037a1635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3c760a9ae9f59b36779dbf8f94cef3"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a0c3c760a9ae9f59b36779dbf8f94cef3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a0c3c760a9ae9f59b36779dbf8f94cef3">distanceTrianglePlane</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;n, T d, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *closestPointTriangle, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *planeProjectionPoint)</td></tr>
<tr class="memdesc:a0c3c760a9ae9f59b36779dbf8f94cef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance of a triangle to a plane.  <a href="#a0c3c760a9ae9f59b36779dbf8f94cef3">More...</a><br /></td></tr>
<tr class="separator:a0c3c760a9ae9f59b36779dbf8f94cef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447f61cf175f70a9c9d0cf854bd1cdd5"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a447f61cf175f70a9c9d0cf854bd1cdd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a447f61cf175f70a9c9d0cf854bd1cdd5">doesIntersectPlanePlane</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pn0, T pd0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;pn1, T pd1, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *pt0, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *pt1)</td></tr>
<tr class="memdesc:a447f61cf175f70a9c9d0cf854bd1cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if two planes are intersecting, if yes also calculate the intersection line.  <a href="#a447f61cf175f70a9c9d0cf854bd1cdd5">More...</a><br /></td></tr>
<tr class="separator:a447f61cf175f70a9c9d0cf854bd1cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0a4678f7e9c87ccc972967ee75cfa7"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:abf0a4678f7e9c87ccc972967ee75cfa7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#abf0a4678f7e9c87ccc972967ee75cfa7">distanceSegmentTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *segmentPoint, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *trianglePoint)</td></tr>
<tr class="memdesc:abf0a4678f7e9c87ccc972967ee75cfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance of a line segment to a triangle.  <a href="#abf0a4678f7e9c87ccc972967ee75cfa7">More...</a><br /></td></tr>
<tr class="separator:abf0a4678f7e9c87ccc972967ee75cfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8758111b69f11c1ab4335295f0865792"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a8758111b69f11c1ab4335295f0865792"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a8758111b69f11c1ab4335295f0865792">distanceSegmentTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;tv2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;normal, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *segmentPoint, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *trianglePoint)</td></tr>
<tr class="memdesc:a8758111b69f11c1ab4335295f0865792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance of a line segment to a triangle.  <a href="#a8758111b69f11c1ab4335295f0865792">More...</a><br /></td></tr>
<tr class="separator:a8758111b69f11c1ab4335295f0865792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c7d7236824c7d00ffbe0238d408d1"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a849c7d7236824c7d00ffbe0238d408d1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a849c7d7236824c7d00ffbe0238d408d1">distanceTriangleTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v2, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *closestPoint0, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *closestPoint1)</td></tr>
<tr class="memdesc:a849c7d7236824c7d00ffbe0238d408d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance between two triangles.  <a href="#a849c7d7236824c7d00ffbe0238d408d1">More...</a><br /></td></tr>
<tr class="separator:a849c7d7236824c7d00ffbe0238d408d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681860a95cf954659d67a644e44ba52d"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a681860a95cf954659d67a644e44ba52d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a681860a95cf954659d67a644e44ba52d">intersectionsSegmentBox</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;sv1, const Eigen::AlignedBox&lt; T, 3 &gt; &amp;box, std::vector&lt; Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &gt; *intersections)</td></tr>
<tr class="memdesc:a681860a95cf954659d67a644e44ba52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the intersections between a line segment and an axis aligned box.  <a href="#a681860a95cf954659d67a644e44ba52d">More...</a><br /></td></tr>
<tr class="separator:a681860a95cf954659d67a644e44ba52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2071a58948bbe0b4c1ea3d720926019"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:aa2071a58948bbe0b4c1ea3d720926019"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aa2071a58948bbe0b4c1ea3d720926019">doesIntersectBoxCapsule</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;capsuleBottom, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;capsuleTop, const T capsuleRadius, const Eigen::AlignedBox&lt; T, 3 &gt; &amp;box)</td></tr>
<tr class="memdesc:aa2071a58948bbe0b4c1ea3d720926019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an axis aligned box intersects with a capsule.  <a href="#aa2071a58948bbe0b4c1ea3d720926019">More...</a><br /></td></tr>
<tr class="separator:aa2071a58948bbe0b4c1ea3d720926019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add58a64be0b70e6c82a3941ca1d09a88"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:add58a64be0b70e6c82a3941ca1d09a88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#add58a64be0b70e6c82a3941ca1d09a88">doesIntersectTriangleTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0n, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1n)</td></tr>
<tr class="memdesc:add58a64be0b70e6c82a3941ca1d09a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two triangles intersect using separating axis test.  <a href="#add58a64be0b70e6c82a3941ca1d09a88">More...</a><br /></td></tr>
<tr class="separator:add58a64be0b70e6c82a3941ca1d09a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b62c761e8886957c058713bf0a46562"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a9b62c761e8886957c058713bf0a46562"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a9b62c761e8886957c058713bf0a46562">doesIntersectTriangleTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v2)</td></tr>
<tr class="memdesc:a9b62c761e8886957c058713bf0a46562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two triangles intersect using separating axis test.  <a href="#a9b62c761e8886957c058713bf0a46562">More...</a><br /></td></tr>
<tr class="separator:a9b62c761e8886957c058713bf0a46562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ba7f07ccda85f48033405f9dad88b9"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a30ba7f07ccda85f48033405f9dad88b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a30ba7f07ccda85f48033405f9dad88b9">calculateContactTriangleTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0n, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1n, T *penetrationDepth, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *penetrationPoint0, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *penetrationPoint1, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *contactNormal)</td></tr>
<tr class="memdesc:a30ba7f07ccda85f48033405f9dad88b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the contact between two triangles.  <a href="#a30ba7f07ccda85f48033405f9dad88b9">More...</a><br /></td></tr>
<tr class="separator:a30ba7f07ccda85f48033405f9dad88b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef86a4800f30ac476b0a9e7f8195129"><td class="memTemplParams" colspan="2">template&lt;class T , int MOpt&gt; </td></tr>
<tr class="memitem:a3ef86a4800f30ac476b0a9e7f8195129"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a3ef86a4800f30ac476b0a9e7f8195129">calculateContactTriangleTriangle</a> (const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t0v2, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v0, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v1, const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;t1v2, T *penetrationDepth, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *penetrationPoint0, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *penetrationPoint1, Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *contactNormal)</td></tr>
<tr class="memdesc:a3ef86a4800f30ac476b0a9e7f8195129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the contact between two triangles.  <a href="#a3ef86a4800f30ac476b0a9e7f8195129">More...</a><br /></td></tr>
<tr class="separator:a3ef86a4800f30ac476b0a9e7f8195129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255fd32bc9937a9002db27fd9f4340ce"><td class="memTemplParams" colspan="2">template&lt;typename T , int VOpt&gt; </td></tr>
<tr class="memitem:a255fd32bc9937a9002db27fd9f4340ce"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a255fd32bc9937a9002db27fd9f4340ce">makeRotationMatrix</a> (const T &amp;angle, const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;axis)</td></tr>
<tr class="memdesc:a255fd32bc9937a9002db27fd9f4340ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rotation matrix corresponding to the specified angle (in radians) and axis.  <a href="#a255fd32bc9937a9002db27fd9f4340ce">More...</a><br /></td></tr>
<tr class="separator:a255fd32bc9937a9002db27fd9f4340ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096cb6059be3c8cc153b7ca1aa38e875"><td class="memTemplParams" colspan="2">template&lt;typename T , int VOpt&gt; </td></tr>
<tr class="memitem:a096cb6059be3c8cc153b7ca1aa38e875"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a096cb6059be3c8cc153b7ca1aa38e875">makeSkewSymmetricMatrix</a> (const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;vector)</td></tr>
<tr class="memdesc:a096cb6059be3c8cc153b7ca1aa38e875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a skew-symmetric matrix corresponding to the specified vector.  <a href="#a096cb6059be3c8cc153b7ca1aa38e875">More...</a><br /></td></tr>
<tr class="separator:a096cb6059be3c8cc153b7ca1aa38e875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cbd55a53a75994beac2e002ec39d6c"><td class="memTemplParams" colspan="2">template&lt;typename T , int MOpt&gt; </td></tr>
<tr class="memitem:a37cbd55a53a75994beac2e002ec39d6c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a37cbd55a53a75994beac2e002ec39d6c">skew</a> (const Eigen::Matrix&lt; T, 3, 3, MOpt &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a37cbd55a53a75994beac2e002ec39d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the unique vector from the skew-symmetric part of a given matrix.  <a href="#a37cbd55a53a75994beac2e002ec39d6c">More...</a><br /></td></tr>
<tr class="separator:a37cbd55a53a75994beac2e002ec39d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f21f5fb9c9297a330a1a48da586ae63"><td class="memTemplParams" colspan="2">template&lt;typename T , int MOpt, int VOpt&gt; </td></tr>
<tr class="memitem:a4f21f5fb9c9297a330a1a48da586ae63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a4f21f5fb9c9297a330a1a48da586ae63">computeAngleAndAxis</a> (const Eigen::Matrix&lt; T, 3, 3, MOpt &gt; &amp;matrix, T *angle, Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *axis)</td></tr>
<tr class="memdesc:a4f21f5fb9c9297a330a1a48da586ae63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angle (in radians) and axis corresponding to a rotation matrix.  <a href="#a4f21f5fb9c9297a330a1a48da586ae63">More...</a><br /></td></tr>
<tr class="separator:a4f21f5fb9c9297a330a1a48da586ae63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27356ff42fbf064f5e061d07bbc4654"><td class="memTemplParams" colspan="2">template&lt;typename T , int MOpt&gt; </td></tr>
<tr class="memitem:aa27356ff42fbf064f5e061d07bbc4654"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aa27356ff42fbf064f5e061d07bbc4654">computeAngle</a> (const Eigen::Matrix&lt; T, 3, 3, MOpt &gt; &amp;matrix)</td></tr>
<tr class="memdesc:aa27356ff42fbf064f5e061d07bbc4654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angle corresponding to a quaternion's rotation, in radians.  <a href="#aa27356ff42fbf064f5e061d07bbc4654">More...</a><br /></td></tr>
<tr class="separator:aa27356ff42fbf064f5e061d07bbc4654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7be385e098d4c5bd8cc9d0bd720e1f"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class SubMatrix &gt; </td></tr>
<tr class="memitem:add7be385e098d4c5bd8cc9d0bd720e1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#add7be385e098d4c5bd8cc9d0bd720e1f">addSubMatrix</a> (const SubMatrix &amp;subMatrix, size_t blockIdRow, size_t blockIdCol, size_t blockSizeRow, size_t blockSizeCol, <a class="el" href="namespaceSurgSim_1_1Math.html#a09630a3dd9bc5c78f9a68a313e4582ab">Matrix</a> *matrix)</td></tr>
<tr class="memdesc:add7be385e098d4c5bd8cc9d0bd720e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to add a sub-matrix into a matrix, for the sake of clarity.  <a href="#add7be385e098d4c5bd8cc9d0bd720e1f">More...</a><br /></td></tr>
<tr class="separator:add7be385e098d4c5bd8cc9d0bd720e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176e571983ce1dff3f5d14d8172942cd"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class SubMatrix &gt; </td></tr>
<tr class="memitem:a176e571983ce1dff3f5d14d8172942cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a176e571983ce1dff3f5d14d8172942cd">addSubMatrix</a> (const SubMatrix &amp;subMatrix, const std::vector&lt; size_t &gt; blockIds, size_t blockSize, <a class="el" href="namespaceSurgSim_1_1Math.html#a09630a3dd9bc5c78f9a68a313e4582ab">Matrix</a> *matrix)</td></tr>
<tr class="memdesc:a176e571983ce1dff3f5d14d8172942cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to add a sub-matrix made of squared-blocks into a matrix, for the sake of clarity.  <a href="#a176e571983ce1dff3f5d14d8172942cd">More...</a><br /></td></tr>
<tr class="separator:a176e571983ce1dff3f5d14d8172942cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac74c4216c96b3a89cc181fc2be3538"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class SubMatrix &gt; </td></tr>
<tr class="memitem:a3ac74c4216c96b3a89cc181fc2be3538"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a3ac74c4216c96b3a89cc181fc2be3538">setSubMatrix</a> (const SubMatrix &amp;subMatrix, size_t blockIdRow, size_t blockIdCol, size_t blockSizeRow, size_t blockSizeCol, <a class="el" href="namespaceSurgSim_1_1Math.html#a09630a3dd9bc5c78f9a68a313e4582ab">Matrix</a> *matrix)</td></tr>
<tr class="memdesc:a3ac74c4216c96b3a89cc181fc2be3538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to set a sub-matrix into a matrix, for the sake of clarity.  <a href="#a3ac74c4216c96b3a89cc181fc2be3538">More...</a><br /></td></tr>
<tr class="separator:a3ac74c4216c96b3a89cc181fc2be3538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb4b9567782673f3f932980b40c73d9"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a8fb4b9567782673f3f932980b40c73d9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; <a class="el" href="namespaceSurgSim_1_1Math.html#a09630a3dd9bc5c78f9a68a313e4582ab">Matrix</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a8fb4b9567782673f3f932980b40c73d9">getSubMatrix</a> (<a class="el" href="namespaceSurgSim_1_1Math.html#a09630a3dd9bc5c78f9a68a313e4582ab">Matrix</a> &amp;matrix, size_t blockIdRow, size_t blockIdCol, size_t blockSizeRow, size_t blockSizeCol)</td></tr>
<tr class="memdesc:a8fb4b9567782673f3f932980b40c73d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to access a sub-matrix from a matrix, for the sake of clarity.  <a href="#a8fb4b9567782673f3f932980b40c73d9">More...</a><br /></td></tr>
<tr class="separator:a8fb4b9567782673f3f932980b40c73d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d77f496910642c6eb9524d75fba8867"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a3d77f496910642c6eb9524d75fba8867">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1MeshShape.html">SurgSim::Math::MeshShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1MeshShape.html">MeshShape</a>)</td></tr>
<tr class="separator:a3d77f496910642c6eb9524d75fba8867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f644cbf25cda3fd15c277a080531706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a0f644cbf25cda3fd15c277a080531706">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1MeshShape.html">MeshShape</a>)</td></tr>
<tr class="separator:a0f644cbf25cda3fd15c277a080531706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a23aa103fcbc4d5381d8a473f54de78"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a0a23aa103fcbc4d5381d8a473f54de78">getMlcpConstraintTypeName</a> (<a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844">MlcpConstraintType</a> constraintType)</td></tr>
<tr class="separator:a0a23aa103fcbc4d5381d8a473f54de78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaa333f24a25241844b3a2e6bac7396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844">MlcpConstraintType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#afdaa333f24a25241844b3a2e6bac7396">getMlcpConstraintTypeValue</a> (const std::string &amp;typeName)</td></tr>
<tr class="separator:afdaa333f24a25241844b3a2e6bac7396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdff4fb4e711cc93b36e322bca8d4e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a6fdff4fb4e711cc93b36e322bca8d4e2">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1OctreeShape.html">SurgSim::Math::OctreeShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1OctreeShape.html">OctreeShape</a>)</td></tr>
<tr class="separator:a6fdff4fb4e711cc93b36e322bca8d4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5dbd42c0d7070684667bc9484882fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#afe5dbd42c0d7070684667bc9484882fc">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1OctreeShape.html">OctreeShape</a>)</td></tr>
<tr class="separator:afe5dbd42c0d7070684667bc9484882fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec9148ef065742f2a0fe51625f476c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a62ec9148ef065742f2a0fe51625f476c">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1PlaneShape.html">SurgSim::Math::PlaneShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1PlaneShape.html">PlaneShape</a>)</td></tr>
<tr class="separator:a62ec9148ef065742f2a0fe51625f476c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31cbb9946189dfd4453018b1202e7e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ab31cbb9946189dfd4453018b1202e7e1">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1PlaneShape.html">PlaneShape</a>)</td></tr>
<tr class="separator:ab31cbb9946189dfd4453018b1202e7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf2dcddf489123bf60c75a6d347596"><td class="memTemplParams" colspan="2">template&lt;typename T , int VOpt&gt; </td></tr>
<tr class="memitem:afbbf2dcddf489123bf60c75a6d347596"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#afbbf2dcddf489123bf60c75a6d347596">makeRotationQuaternion</a> (const T &amp;angle, const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;axis)</td></tr>
<tr class="memdesc:afbbf2dcddf489123bf60c75a6d347596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a quaternion rotation corresponding to the specified angle (in radians) and axis.  <a href="#afbbf2dcddf489123bf60c75a6d347596">More...</a><br /></td></tr>
<tr class="separator:afbbf2dcddf489123bf60c75a6d347596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5101db9404f2a4bd8284ae6c5de1051"><td class="memTemplParams" colspan="2">template&lt;typename T , int QOpt&gt; </td></tr>
<tr class="memitem:ad5101db9404f2a4bd8284ae6c5de1051"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T, QOpt &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ad5101db9404f2a4bd8284ae6c5de1051">negate</a> (const Eigen::Quaternion&lt; T, QOpt &gt; &amp;q)</td></tr>
<tr class="memdesc:ad5101db9404f2a4bd8284ae6c5de1051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quaternion negation (i.e.  <a href="#ad5101db9404f2a4bd8284ae6c5de1051">More...</a><br /></td></tr>
<tr class="separator:ad5101db9404f2a4bd8284ae6c5de1051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a27b656526e7ee9c22691100afb375d"><td class="memTemplParams" colspan="2">template&lt;typename T , int QOpt, int VOpt&gt; </td></tr>
<tr class="memitem:a4a27b656526e7ee9c22691100afb375d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a4a27b656526e7ee9c22691100afb375d">computeAngleAndAxis</a> (const Eigen::Quaternion&lt; T, QOpt &gt; &amp;quaternion, T *angle, Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *axis)</td></tr>
<tr class="memdesc:a4a27b656526e7ee9c22691100afb375d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angle (in radians) and axis corresponding to a quaternion's rotation.  <a href="#a4a27b656526e7ee9c22691100afb375d">More...</a><br /></td></tr>
<tr class="separator:a4a27b656526e7ee9c22691100afb375d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92db114456cae24f4f99f865dbab7a57"><td class="memTemplParams" colspan="2">template&lt;typename T , int QOpt&gt; </td></tr>
<tr class="memitem:a92db114456cae24f4f99f865dbab7a57"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a92db114456cae24f4f99f865dbab7a57">computeAngle</a> (const Eigen::Quaternion&lt; T, QOpt &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:a92db114456cae24f4f99f865dbab7a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angle corresponding to a quaternion's rotation, in radians.  <a href="#a92db114456cae24f4f99f865dbab7a57">More...</a><br /></td></tr>
<tr class="separator:a92db114456cae24f4f99f865dbab7a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbc7a1a85731d1a9a74c293054eb77a"><td class="memTemplParams" colspan="2">template&lt;typename T , int TOpt, int VOpt&gt; </td></tr>
<tr class="memitem:a8fbc7a1a85731d1a9a74c293054eb77a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a8fbc7a1a85731d1a9a74c293054eb77a">computeRotationVector</a> (const Eigen::Transform&lt; T, 3, Eigen::Isometry, TOpt &gt; &amp;end, const Eigen::Transform&lt; T, 3, Eigen::Isometry, TOpt &gt; &amp;start, Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *rotationVector)</td></tr>
<tr class="memdesc:a8fbc7a1a85731d1a9a74c293054eb77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector corresponding to the rotation between transforms.  <a href="#a8fbc7a1a85731d1a9a74c293054eb77a">More...</a><br /></td></tr>
<tr class="separator:a8fbc7a1a85731d1a9a74c293054eb77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af497ebd6ee555a1dfcdff2cfba26d422"><td class="memTemplParams" colspan="2">template&lt;typename T , int QOpt&gt; </td></tr>
<tr class="memitem:af497ebd6ee555a1dfcdff2cfba26d422"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T, QOpt &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#af497ebd6ee555a1dfcdff2cfba26d422">interpolate</a> (const Eigen::Quaternion&lt; T, QOpt &gt; &amp;q0, const Eigen::Quaternion&lt; T, QOpt &gt; &amp;q1, T t)</td></tr>
<tr class="memdesc:af497ebd6ee555a1dfcdff2cfba26d422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate (slerp) between 2 quaternions.  <a href="#af497ebd6ee555a1dfcdff2cfba26d422">More...</a><br /></td></tr>
<tr class="separator:af497ebd6ee555a1dfcdff2cfba26d422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3946fbd295cbf3342a6f4358ef9e3a"><td class="memTemplParams" colspan="2">template&lt;typename M , typename V &gt; </td></tr>
<tr class="memitem:a3f3946fbd295cbf3342a6f4358ef9e3a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Transform&lt; typename <br class="typebreak" />
M::Scalar, <br class="typebreak" />
M::RowsAtCompileTime, <br class="typebreak" />
Eigen::Isometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a3f3946fbd295cbf3342a6f4358ef9e3a">makeRigidTransform</a> (const Eigen::MatrixBase&lt; M &gt; &amp;rotation, const Eigen::MatrixBase&lt; V &gt; &amp;translation)</td></tr>
<tr class="memdesc:a3f3946fbd295cbf3342a6f4358ef9e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rigid transform using the specified rotation matrix and translation.  <a href="#a3f3946fbd295cbf3342a6f4358ef9e3a">More...</a><br /></td></tr>
<tr class="separator:a3f3946fbd295cbf3342a6f4358ef9e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab55abeabcca76fcd474927834d16d8e"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename V &gt; </td></tr>
<tr class="memitem:aab55abeabcca76fcd474927834d16d8e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Transform&lt; typename <br class="typebreak" />
Q::Scalar, 3, Eigen::Isometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aab55abeabcca76fcd474927834d16d8e">makeRigidTransform</a> (const Eigen::QuaternionBase&lt; Q &gt; &amp;rotation, const Eigen::MatrixBase&lt; V &gt; &amp;translation)</td></tr>
<tr class="memdesc:aab55abeabcca76fcd474927834d16d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rigid transform using the specified rotation quaternion and translation.  <a href="#aab55abeabcca76fcd474927834d16d8e">More...</a><br /></td></tr>
<tr class="separator:aab55abeabcca76fcd474927834d16d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88989dc085efef2d9fdd92ea5ee38e37"><td class="memTemplParams" colspan="2">template&lt;typename T , int VOpt&gt; </td></tr>
<tr class="memitem:a88989dc085efef2d9fdd92ea5ee38e37"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Transform&lt; T, <br class="typebreak" />
3, Eigen::Isometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a88989dc085efef2d9fdd92ea5ee38e37">makeRigidTransform</a> (const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;position, const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;center, const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;up)</td></tr>
<tr class="memdesc:a88989dc085efef2d9fdd92ea5ee38e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a rigid transform from a eye point a center view point and an up direction, does not check whether up is colinear with eye-center The original formula can be found at <a href="http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml">http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml</a>.  <a href="#a88989dc085efef2d9fdd92ea5ee38e37">More...</a><br /></td></tr>
<tr class="separator:a88989dc085efef2d9fdd92ea5ee38e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7787cebfc5b479c219e1b34a53ce13"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a0e7787cebfc5b479c219e1b34a53ce13"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Transform&lt; typename <br class="typebreak" />
V::Scalar, <br class="typebreak" />
V::SizeAtCompileTime, <br class="typebreak" />
Eigen::Isometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a0e7787cebfc5b479c219e1b34a53ce13">makeRigidTranslation</a> (const Eigen::MatrixBase&lt; V &gt; &amp;translation)</td></tr>
<tr class="memdesc:a0e7787cebfc5b479c219e1b34a53ce13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rigid transform using the identity rotation and the specified translation.  <a href="#a0e7787cebfc5b479c219e1b34a53ce13">More...</a><br /></td></tr>
<tr class="separator:a0e7787cebfc5b479c219e1b34a53ce13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1530d6ee41d00de97a3dbe0187fbabd2"><td class="memTemplParams" colspan="2">template&lt;typename T , int TOpt&gt; </td></tr>
<tr class="memitem:a1530d6ee41d00de97a3dbe0187fbabd2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Transform&lt; T, <br class="typebreak" />
3, Eigen::Isometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a1530d6ee41d00de97a3dbe0187fbabd2">interpolate</a> (const Eigen::Transform&lt; T, 3, Eigen::Isometry, TOpt &gt; &amp;t0, const Eigen::Transform&lt; T, 3, Eigen::Isometry, TOpt &gt; &amp;t1, T t)</td></tr>
<tr class="memdesc:a1530d6ee41d00de97a3dbe0187fbabd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate (slerp) between 2 rigid transformations.  <a href="#a1530d6ee41d00de97a3dbe0187fbabd2">More...</a><br /></td></tr>
<tr class="separator:a1530d6ee41d00de97a3dbe0187fbabd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffd80540b75e90ca3d0772bafe68f8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a0ffd80540b75e90ca3d0772bafe68f8b">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1SphereShape.html">SurgSim::Math::SphereShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1SphereShape.html">SphereShape</a>)</td></tr>
<tr class="separator:a0ffd80540b75e90ca3d0772bafe68f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b44c7eb8e60c321741b349584a8cae6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a5b44c7eb8e60c321741b349584a8cae6">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1SphereShape.html">SphereShape</a>)</td></tr>
<tr class="separator:a5b44c7eb8e60c321741b349584a8cae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38f99b9a7c90d81ba68540946da2020"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#af38f99b9a7c90d81ba68540946da2020">SURGSIM_REGISTER</a> (<a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>, <a class="el" href="classSurgSim_1_1Math_1_1SurfaceMeshShape.html">SurgSim::Math::SurfaceMeshShape</a>, <a class="el" href="classSurgSim_1_1Math_1_1SurfaceMeshShape.html">SurfaceMeshShape</a>)</td></tr>
<tr class="separator:af38f99b9a7c90d81ba68540946da2020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84c560b837920b5771866d6c2f37f33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ae84c560b837920b5771866d6c2f37f33">SURGSIM_STATIC_REGISTRATION</a> (<a class="el" href="classSurgSim_1_1Math_1_1SurfaceMeshShape.html">SurfaceMeshShape</a>)</td></tr>
<tr class="separator:ae84c560b837920b5771866d6c2f37f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689366956d4a4dceee90eafc337e73bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a689366956d4a4dceee90eafc337e73bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a689366956d4a4dceee90eafc337e73bf">edgeIntersection</a> (T dStart, T dEnd, T pvStart, T pvEnd, T *parametricIntersection, size_t *parametricIntersectionIndex)</td></tr>
<tr class="memdesc:a689366956d4a4dceee90eafc337e73bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two ends of the triangle edge are given in terms of the following vertex properties.  <a href="#a689366956d4a4dceee90eafc337e73bf">More...</a><br /></td></tr>
<tr class="separator:a689366956d4a4dceee90eafc337e73bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d999883903a13d9fbfae0d74c325c0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a7d999883903a13d9fbfae0d74c325c0a">isValid</a> (float value)</td></tr>
<tr class="memdesc:a7d999883903a13d9fbfae0d74c325c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <code>float</code> value is valid.  <a href="#a7d999883903a13d9fbfae0d74c325c0a">More...</a><br /></td></tr>
<tr class="separator:a7d999883903a13d9fbfae0d74c325c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b445f3e132e0711acc3a6d57a9dd22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a17b445f3e132e0711acc3a6d57a9dd22">isValid</a> (double value)</td></tr>
<tr class="memdesc:a17b445f3e132e0711acc3a6d57a9dd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <code>double</code> value is valid.  <a href="#a17b445f3e132e0711acc3a6d57a9dd22">More...</a><br /></td></tr>
<tr class="separator:a17b445f3e132e0711acc3a6d57a9dd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab9333011ab42799f84f2dfe20a7c24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ab9333011ab42799f84f2dfe20a7c24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a8ab9333011ab42799f84f2dfe20a7c24">isValid</a> (const Eigen::DenseBase&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a8ab9333011ab42799f84f2dfe20a7c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a matrix or a vector is valid.  <a href="#a8ab9333011ab42799f84f2dfe20a7c24">More...</a><br /></td></tr>
<tr class="separator:a8ab9333011ab42799f84f2dfe20a7c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dfef405ae8c4871a2f938d26b0468b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69dfef405ae8c4871a2f938d26b0468b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a69dfef405ae8c4871a2f938d26b0468b">isValid</a> (const Eigen::QuaternionBase&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a69dfef405ae8c4871a2f938d26b0468b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a quaternion is valid.  <a href="#a69dfef405ae8c4871a2f938d26b0468b">More...</a><br /></td></tr>
<tr class="separator:a69dfef405ae8c4871a2f938d26b0468b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137e9685c2d56d4956f7749f95f588c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a137e9685c2d56d4956f7749f95f588c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a137e9685c2d56d4956f7749f95f588c9">isValid</a> (const Eigen::AngleAxis&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a137e9685c2d56d4956f7749f95f588c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an angle/axis 3D rotation is valid.  <a href="#a137e9685c2d56d4956f7749f95f588c9">More...</a><br /></td></tr>
<tr class="separator:a137e9685c2d56d4956f7749f95f588c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0887f0a4909704ad6c2af45203c9f57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0887f0a4909704ad6c2af45203c9f57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ab0887f0a4909704ad6c2af45203c9f57">isValid</a> (const Eigen::Rotation2D&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:ab0887f0a4909704ad6c2af45203c9f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a 2D rotation is valid.  <a href="#ab0887f0a4909704ad6c2af45203c9f57">More...</a><br /></td></tr>
<tr class="separator:ab0887f0a4909704ad6c2af45203c9f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b6235b40cee368631374231308661"><td class="memTemplParams" colspan="2">template&lt;typename T , int D, int M, int O&gt; </td></tr>
<tr class="memitem:a6d8b6235b40cee368631374231308661"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a6d8b6235b40cee368631374231308661">isValid</a> (const Eigen::Transform&lt; T, D, M, O &gt; &amp;value)</td></tr>
<tr class="memdesc:a6d8b6235b40cee368631374231308661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transform is valid.  <a href="#a6d8b6235b40cee368631374231308661">More...</a><br /></td></tr>
<tr class="separator:a6d8b6235b40cee368631374231308661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc08ae33d45df0ba04f01272b9af7460"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#adc08ae33d45df0ba04f01272b9af7460">isSubnormal</a> (float value)</td></tr>
<tr class="memdesc:adc08ae33d45df0ba04f01272b9af7460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <code>float</code> value is subnormal.  <a href="#adc08ae33d45df0ba04f01272b9af7460">More...</a><br /></td></tr>
<tr class="separator:adc08ae33d45df0ba04f01272b9af7460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f417e355801b7df0774434dd87f1b43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a5f417e355801b7df0774434dd87f1b43">isSubnormal</a> (double value)</td></tr>
<tr class="memdesc:a5f417e355801b7df0774434dd87f1b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <code>double</code> value is subnormal.  <a href="#a5f417e355801b7df0774434dd87f1b43">More...</a><br /></td></tr>
<tr class="separator:a5f417e355801b7df0774434dd87f1b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200bb06ccdc27f5e465a46c61aae4088"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a200bb06ccdc27f5e465a46c61aae4088"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a200bb06ccdc27f5e465a46c61aae4088">isSubnormal</a> (const Eigen::DenseBase&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a200bb06ccdc27f5e465a46c61aae4088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a matrix or a vector contains any subnormal floating-point values.  <a href="#a200bb06ccdc27f5e465a46c61aae4088">More...</a><br /></td></tr>
<tr class="separator:a200bb06ccdc27f5e465a46c61aae4088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccd402f82d24ef14ef9c592a75d447a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ccd402f82d24ef14ef9c592a75d447a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a8ccd402f82d24ef14ef9c592a75d447a">isSubnormal</a> (const Eigen::QuaternionBase&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a8ccd402f82d24ef14ef9c592a75d447a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a quaternion contains any subnormal floating-point values.  <a href="#a8ccd402f82d24ef14ef9c592a75d447a">More...</a><br /></td></tr>
<tr class="separator:a8ccd402f82d24ef14ef9c592a75d447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10777876a6a57a79e295762c2371c485"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10777876a6a57a79e295762c2371c485"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a10777876a6a57a79e295762c2371c485">isSubnormal</a> (const Eigen::AngleAxis&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a10777876a6a57a79e295762c2371c485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an angle/axis 3D rotation contains any subnormal floating-point values.  <a href="#a10777876a6a57a79e295762c2371c485">More...</a><br /></td></tr>
<tr class="separator:a10777876a6a57a79e295762c2371c485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592dab5be08b271d0646739139640878"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a592dab5be08b271d0646739139640878"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a592dab5be08b271d0646739139640878">isSubnormal</a> (const Eigen::Rotation2D&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a592dab5be08b271d0646739139640878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a 2D rotation is described by an angle that is subnormal.  <a href="#a592dab5be08b271d0646739139640878">More...</a><br /></td></tr>
<tr class="separator:a592dab5be08b271d0646739139640878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f99ae4252de135283d5ed75fb1a44b3"><td class="memTemplParams" colspan="2">template&lt;typename T , int D, int M, int O&gt; </td></tr>
<tr class="memitem:a6f99ae4252de135283d5ed75fb1a44b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a6f99ae4252de135283d5ed75fb1a44b3">isSubnormal</a> (const Eigen::Transform&lt; T, D, M, O &gt; &amp;value)</td></tr>
<tr class="memdesc:a6f99ae4252de135283d5ed75fb1a44b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transform contains any subnormal floating-point values.  <a href="#a6f99ae4252de135283d5ed75fb1a44b3">More...</a><br /></td></tr>
<tr class="separator:a6f99ae4252de135283d5ed75fb1a44b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d5b1c4a9b3048a0eb2ae6225c64d79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ae8d5b1c4a9b3048a0eb2ae6225c64d79">setSubnormalToZero</a> (float *value)</td></tr>
<tr class="memdesc:ae8d5b1c4a9b3048a0eb2ae6225c64d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code>float</code> value is subnormal, set it to zero.  <a href="#ae8d5b1c4a9b3048a0eb2ae6225c64d79">More...</a><br /></td></tr>
<tr class="separator:ae8d5b1c4a9b3048a0eb2ae6225c64d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233a2e972d0d3ba89c287f9615820792"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a233a2e972d0d3ba89c287f9615820792">setSubnormalToZero</a> (double *value)</td></tr>
<tr class="memdesc:a233a2e972d0d3ba89c287f9615820792"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code>double</code> value is subnormal, set it to zero.  <a href="#a233a2e972d0d3ba89c287f9615820792">More...</a><br /></td></tr>
<tr class="separator:a233a2e972d0d3ba89c287f9615820792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d41f0aaac297fc06cbf95c4a06dfa4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82d41f0aaac297fc06cbf95c4a06dfa4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a82d41f0aaac297fc06cbf95c4a06dfa4">setSubnormalToZero</a> (Eigen::DenseBase&lt; T &gt; *value)</td></tr>
<tr class="memdesc:a82d41f0aaac297fc06cbf95c4a06dfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all subnormal values in a matrix or a vector to zero.  <a href="#a82d41f0aaac297fc06cbf95c4a06dfa4">More...</a><br /></td></tr>
<tr class="separator:a82d41f0aaac297fc06cbf95c4a06dfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f58c4e6daec2d279a4911c8ab4d0183"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f58c4e6daec2d279a4911c8ab4d0183"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a5f58c4e6daec2d279a4911c8ab4d0183">setSubnormalToZero</a> (Eigen::QuaternionBase&lt; T &gt; *value)</td></tr>
<tr class="memdesc:a5f58c4e6daec2d279a4911c8ab4d0183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all subnormal values in a quaternion to zero.  <a href="#a5f58c4e6daec2d279a4911c8ab4d0183">More...</a><br /></td></tr>
<tr class="separator:a5f58c4e6daec2d279a4911c8ab4d0183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62671eec2c1c9182efed516d77f3db1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62671eec2c1c9182efed516d77f3db1f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a62671eec2c1c9182efed516d77f3db1f">setSubnormalToZero</a> (Eigen::AngleAxis&lt; T &gt; *value)</td></tr>
<tr class="memdesc:a62671eec2c1c9182efed516d77f3db1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all subnormal values in an angle/axis 3D rotation to zero.  <a href="#a62671eec2c1c9182efed516d77f3db1f">More...</a><br /></td></tr>
<tr class="separator:a62671eec2c1c9182efed516d77f3db1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbd67f246c9cfda1afea747f99325a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebbd67f246c9cfda1afea747f99325a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aebbd67f246c9cfda1afea747f99325a3">setSubnormalToZero</a> (Eigen::Rotation2D&lt; T &gt; *value)</td></tr>
<tr class="memdesc:aebbd67f246c9cfda1afea747f99325a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the angle of a 2D rotation is subnormal, set it to zero.  <a href="#aebbd67f246c9cfda1afea747f99325a3">More...</a><br /></td></tr>
<tr class="separator:aebbd67f246c9cfda1afea747f99325a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af753cbd2ae10c85d0236c4d216a2819a"><td class="memTemplParams" colspan="2">template&lt;typename T , int D, int M, int O&gt; </td></tr>
<tr class="memitem:af753cbd2ae10c85d0236c4d216a2819a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#af753cbd2ae10c85d0236c4d216a2819a">setSubnormalToZero</a> (Eigen::Transform&lt; T, D, M, O &gt; *value)</td></tr>
<tr class="memdesc:af753cbd2ae10c85d0236c4d216a2819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all subnormal values in a transform to zero.  <a href="#af753cbd2ae10c85d0236c4d216a2819a">More...</a><br /></td></tr>
<tr class="separator:af753cbd2ae10c85d0236c4d216a2819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68e540a33a0fffb833c0e52e0ba4aa1"><td class="memTemplParams" colspan="2">template&lt;class Vector , class SubVector &gt; </td></tr>
<tr class="memitem:ad68e540a33a0fffb833c0e52e0ba4aa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ad68e540a33a0fffb833c0e52e0ba4aa1">addSubVector</a> (const SubVector &amp;subVector, size_t blockId, size_t blockSize, <a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">Vector</a> *vector)</td></tr>
<tr class="memdesc:ad68e540a33a0fffb833c0e52e0ba4aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to add a sub-vector into a vector, for the sake of clarity.  <a href="#ad68e540a33a0fffb833c0e52e0ba4aa1">More...</a><br /></td></tr>
<tr class="separator:ad68e540a33a0fffb833c0e52e0ba4aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316d75fb1c95bd6de686e107cc96f813"><td class="memTemplParams" colspan="2">template&lt;class Vector , class SubVector &gt; </td></tr>
<tr class="memitem:a316d75fb1c95bd6de686e107cc96f813"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a316d75fb1c95bd6de686e107cc96f813">addSubVector</a> (const SubVector &amp;subVector, const std::vector&lt; size_t &gt; blockIds, size_t blockSize, <a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">Vector</a> *vector)</td></tr>
<tr class="memdesc:a316d75fb1c95bd6de686e107cc96f813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to add a sub-vector per block into a vector, for the sake of clarity.  <a href="#a316d75fb1c95bd6de686e107cc96f813">More...</a><br /></td></tr>
<tr class="separator:a316d75fb1c95bd6de686e107cc96f813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafb55af05cd84854fe69b9aeaeca367"><td class="memTemplParams" colspan="2">template&lt;class Vector , class SubVector &gt; </td></tr>
<tr class="memitem:acafb55af05cd84854fe69b9aeaeca367"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#acafb55af05cd84854fe69b9aeaeca367">setSubVector</a> (const SubVector &amp;subVector, size_t blockId, size_t blockSize, <a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">Vector</a> *vector)</td></tr>
<tr class="memdesc:acafb55af05cd84854fe69b9aeaeca367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to set a sub-vector into a vector, for the sake of clarity.  <a href="#acafb55af05cd84854fe69b9aeaeca367">More...</a><br /></td></tr>
<tr class="separator:acafb55af05cd84854fe69b9aeaeca367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1b1178f052b4ae1a1af19e581c8e49"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:adf1b1178f052b4ae1a1af19e581c8e49"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">Vector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#adf1b1178f052b4ae1a1af19e581c8e49">getSubVector</a> (<a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">Vector</a> &amp;vector, size_t blockId, size_t blockSize)</td></tr>
<tr class="memdesc:adf1b1178f052b4ae1a1af19e581c8e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to access a sub-vector from a vector, for the sake of clarity.  <a href="#adf1b1178f052b4ae1a1af19e581c8e49">More...</a><br /></td></tr>
<tr class="separator:adf1b1178f052b4ae1a1af19e581c8e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf898c8281825775e047559511eddae"><td class="memTemplParams" colspan="2">template&lt;class Vector , class SubVector &gt; </td></tr>
<tr class="memitem:abaf898c8281825775e047559511eddae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#abaf898c8281825775e047559511eddae">getSubVector</a> (const <a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">Vector</a> &amp;vector, const std::vector&lt; size_t &gt; blockIds, size_t blockSize, SubVector *subVector)</td></tr>
<tr class="memdesc:abaf898c8281825775e047559511eddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to get a sub-vector per block from a vector, for the sake of clarity.  <a href="#abaf898c8281825775e047559511eddae">More...</a><br /></td></tr>
<tr class="separator:abaf898c8281825775e047559511eddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9b5ba71a0dbd8d53d44e09f4a27d70"><td class="memTemplParams" colspan="2">template&lt;typename T , int size, int TOpt&gt; </td></tr>
<tr class="memitem:a6a9b5ba71a0dbd8d53d44e09f4a27d70"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, size, 1, TOpt &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a6a9b5ba71a0dbd8d53d44e09f4a27d70">interpolate</a> (const Eigen::Matrix&lt; T, size, 1, TOpt &gt; &amp;previous, const Eigen::Matrix&lt; T, size, 1, TOpt &gt; &amp;next, T t)</td></tr>
<tr class="memdesc:a6a9b5ba71a0dbd8d53d44e09f4a27d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate (slerp) between 2 vectors.  <a href="#a6a9b5ba71a0dbd8d53d44e09f4a27d70">More...</a><br /></td></tr>
<tr class="separator:a6a9b5ba71a0dbd8d53d44e09f4a27d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b46381ac5e692962fbe55b6f4f96c61"><td class="memTemplParams" colspan="2">template&lt;class T , int VOpt&gt; </td></tr>
<tr class="memitem:a5b46381ac5e692962fbe55b6f4f96c61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a5b46381ac5e692962fbe55b6f4f96c61">buildOrthonormalBasis</a> (Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *i, Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *j, Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *k)</td></tr>
<tr class="memdesc:a5b46381ac5e692962fbe55b6f4f96c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to construct an orthonormal basis (i, j, k) given the 1st vector direction.  <a href="#a5b46381ac5e692962fbe55b6f4f96c61">More...</a><br /></td></tr>
<tr class="separator:a5b46381ac5e692962fbe55b6f4f96c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a988836fe863ef78265350fc669f105b4"><td class="memItemLeft" align="right" valign="top">std::array<br class="typebreak" />
&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a988836fe863ef78265350fc669f105b4">gaussQuadrature1Point</a></td></tr>
<tr class="memdesc:a988836fe863ef78265350fc669f105b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-point Gauss-Legendre quadrature {&lt;x_1, w_1&gt;}  <a href="#a988836fe863ef78265350fc669f105b4">More...</a><br /></td></tr>
<tr class="separator:a988836fe863ef78265350fc669f105b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafb88e552f9f5fa3a54a609e1c997c6"><td class="memItemLeft" align="right" valign="top">std::array<br class="typebreak" />
&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#aeafb88e552f9f5fa3a54a609e1c997c6">gaussQuadrature2Points</a></td></tr>
<tr class="memdesc:aeafb88e552f9f5fa3a54a609e1c997c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;}  <a href="#aeafb88e552f9f5fa3a54a609e1c997c6">More...</a><br /></td></tr>
<tr class="separator:aeafb88e552f9f5fa3a54a609e1c997c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549a3320c54b0c3ed5226463bc718f1a"><td class="memItemLeft" align="right" valign="top">std::array<br class="typebreak" />
&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a549a3320c54b0c3ed5226463bc718f1a">gaussQuadrature3Points</a></td></tr>
<tr class="memdesc:a549a3320c54b0c3ed5226463bc718f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;, &lt;x_3, w_3&gt;}  <a href="#a549a3320c54b0c3ed5226463bc718f1a">More...</a><br /></td></tr>
<tr class="separator:a549a3320c54b0c3ed5226463bc718f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06638bc0d2e6a9fae5c8aba928638e34"><td class="memItemLeft" align="right" valign="top">std::array<br class="typebreak" />
&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a06638bc0d2e6a9fae5c8aba928638e34">gaussQuadrature4Points</a></td></tr>
<tr class="memdesc:a06638bc0d2e6a9fae5c8aba928638e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">4-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;, &lt;x_3, w_3&gt;, &lt;x_4, w_4&gt;}  <a href="#a06638bc0d2e6a9fae5c8aba928638e34">More...</a><br /></td></tr>
<tr class="separator:a06638bc0d2e6a9fae5c8aba928638e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226061422fe4dd21c4faf1887223be61"><td class="memItemLeft" align="right" valign="top">std::array<br class="typebreak" />
&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#a226061422fe4dd21c4faf1887223be61">gaussQuadrature5Points</a></td></tr>
<tr class="memdesc:a226061422fe4dd21c4faf1887223be61"><td class="mdescLeft">&#160;</td><td class="mdescRight">5-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;, &lt;x_3, w_3&gt;, &lt;x_4, w_4&gt;, &lt;x_5, w_5&gt;}  <a href="#a226061422fe4dd21c4faf1887223be61">More...</a><br /></td></tr>
<tr class="separator:a226061422fe4dd21c4faf1887223be61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8213a4e895f7ee0ddebd8a697d059c5"><td class="memItemLeft" align="right" valign="top">std::array<br class="typebreak" />
&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 100 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ad8213a4e895f7ee0ddebd8a697d059c5">gaussQuadrature100Points</a></td></tr>
<tr class="memdesc:ad8213a4e895f7ee0ddebd8a697d059c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">100-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;, &lt;x_3, w_3&gt;, ..., &lt;x_100, w_100&gt;}  <a href="#ad8213a4e895f7ee0ddebd8a697d059c5">More...</a><br /></td></tr>
<tr class="separator:ad8213a4e895f7ee0ddebd8a697d059c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40bcb0b6821df71823c00e764a6a6e0"><td class="memItemLeft" align="right" valign="top">const std::unordered_map<br class="typebreak" />
&lt; <a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125">IntegrationScheme</a>, <br class="typebreak" />
std::string, std::hash&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSurgSim_1_1Math.html#ae40bcb0b6821df71823c00e764a6a6e0">IntegrationSchemeNames</a></td></tr>
<tr class="separator:ae40bcb0b6821df71823c00e764a6a6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a46c5daa850a324fbfc23a003043879bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::AlignedBox&lt;double, 3&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a46c5daa850a324fbfc23a003043879bc">SurgSim::Math::Aabbd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around the <a class="el" href="namespaceEigen.html">Eigen</a> type. </p>

</div>
</div>
<a class="anchor" id="a98699f544aaca521aadf2b9aaac42e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::AlignedBox&lt;float, 3&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a98699f544aaca521aadf2b9aaac42e8f">SurgSim::Math::Aabbf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around the <a class="el" href="namespaceEigen.html">Eigen</a> type. </p>

</div>
</div>
<a class="anchor" id="ad5e6600f6851d0ce2b751e6732de6325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::DiagonalMatrix&lt;double, Eigen::Dynamic&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#ad5e6600f6851d0ce2b751e6732de6325">SurgSim::Math::DiagonalMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dynamic size diagonal matrix. </p>

</div>
</div>
<a class="anchor" id="a09630a3dd9bc5c78f9a68a313e4582ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a09630a3dd9bc5c78f9a68a313e4582ab">SurgSim::Math::Matrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dynamic size matrix. </p>

</div>
</div>
<a class="anchor" id="a1a0a9633eeb333f594a0303d6e114e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 2, 2, Eigen::RowMajor&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a1a0a9633eeb333f594a0303d6e114e4a">SurgSim::Math::Matrix22d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x2 matrix of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="afaed4c38a810334c3426810a901941c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, 2, 2, Eigen::RowMajor&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#afaed4c38a810334c3426810a901941c4">SurgSim::Math::Matrix22f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x2 matrix of floats. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="af7e759a037e742d33d39c187a047e98d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 3, 3, Eigen::RowMajor&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#af7e759a037e742d33d39c187a047e98d">SurgSim::Math::Matrix33d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x3 matrix of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a182881b84e0a2b0caa7f2fc59490a11f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, 3, 3, Eigen::RowMajor&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a182881b84e0a2b0caa7f2fc59490a11f">SurgSim::Math::Matrix33f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x3 matrix of floats. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="aff80c35c6bee7833ddcf6ab5cbc6384f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 4, 4, Eigen::RowMajor&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#aff80c35c6bee7833ddcf6ab5cbc6384f">SurgSim::Math::Matrix44d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x4 matrix of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a3d3265d7be70bc60e14022333382ebd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, 4, 4, Eigen::RowMajor&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a3d3265d7be70bc60e14022333382ebd2">SurgSim::Math::Matrix44f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x4 matrix of floats. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a5a698014f73410555fb4b7826a3e0419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 6, 6, Eigen::RowMajor&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a5a698014f73410555fb4b7826a3e0419">SurgSim::Math::Matrix66d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 6x6 matrix of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a8deb517a88b1991f65d786ffc4b7a1d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Quaternion&lt;double&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a8deb517a88b1991f65d786ffc4b7a1d8">SurgSim::Math::Quaterniond</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A quaternion of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="ac8d585e90e738cb258d51902492be521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Quaternion&lt;float&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#ac8d585e90e738cb258d51902492be521">SurgSim::Math::Quaternionf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A quaternion of floats. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a614d9cdc331250878cd7c6409bacb06d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Transform&lt;double, 2, Eigen::Isometry&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a614d9cdc331250878cd7c6409bacb06d">SurgSim::Math::RigidTransform2d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2D rigid (isometric) transform, represented as doubles. </p>
<p>This type (and any struct that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a78b4e059748b22e737077e421a6eefa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Transform&lt;float, 2, Eigen::Isometry&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a78b4e059748b22e737077e421a6eefa5">SurgSim::Math::RigidTransform2f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2D rigid (isometric) transform, represented as floats. </p>
<p>This type (and any struct that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="ab5702b833ce6119c68ad5e014144217a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Transform&lt;double, 3, Eigen::Isometry&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#ab5702b833ce6119c68ad5e014144217a">SurgSim::Math::RigidTransform3d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3D rigid (isometric) transform, represented as doubles. </p>
<p>This type (and any struct that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a6a94492b43148dcbe1367ed5a8db18c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Transform&lt;float, 3, Eigen::Isometry&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a6a94492b43148dcbe1367ed5a8db18c1">SurgSim::Math::RigidTransform3f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3D rigid (isometric) transform, represented as floats. </p>
<p>This type (and any struct that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="ad0bac671a4eb2e7e762ac8b836e941a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">SurgSim::Math::Vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dynamic size column vector. </p>

</div>
</div>
<a class="anchor" id="a4aa132b3b1bf6eab903c1842e8cd2024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 2, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a4aa132b3b1bf6eab903c1842e8cd2024">SurgSim::Math::Vector2d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2D vector of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a81114e23eb642de3f621c04b3ac02faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, 2, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a81114e23eb642de3f621c04b3ac02faa">SurgSim::Math::Vector2f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2D vector of floats. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a4ae052fe9c89b6abb1dc047ed830ef35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 3, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a4ae052fe9c89b6abb1dc047ed830ef35">SurgSim::Math::Vector3d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3D vector of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="afa9ff4319e35f1e6a42b46a3c07b07ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, 3, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#afa9ff4319e35f1e6a42b46a3c07b07ed">SurgSim::Math::Vector3f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3D vector of floats. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="ad74b1307bea307b4356af0e96721a9e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 4, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#ad74b1307bea307b4356af0e96721a9e2">SurgSim::Math::Vector4d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4D vector of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a692cb10c56f5da2368712efd498d5caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, 4, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a692cb10c56f5da2368712efd498d5caa">SurgSim::Math::Vector4f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4D vector of floats. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a52cd0db17727d3f7dbeea479aecf9b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 6, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a52cd0db17727d3f7dbeea479aecf9b2e">SurgSim::Math::Vector6d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 6D matrix of doubles. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<a class="anchor" id="a1e9219b6491829f484eaa69bbb0cfa5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;float, 6, 1&gt; <a class="el" href="namespaceSurgSim_1_1Math.html#a1e9219b6491829f484eaa69bbb0cfa5e">SurgSim::Math::Vector6f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 6D vector of floats. </p>
<p>This type (and any structs that contain it) can be safely allocated via new. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125">SurgSim::Math::IntegrationScheme</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The diverse numerical integration scheme supported Each Ode Solver should have its own entry in this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125a6edc630aa3769d421af13c101c51a50f"></a>INTEGRATIONSCHEME_STATIC&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125abe1e7fef146cc2287a993a19e3ca32a9"></a>INTEGRATIONSCHEME_LINEAR_STATIC&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125a998867da87fd8a2ffc652433a8f7a1b8"></a>INTEGRATIONSCHEME_EXPLICIT_EULER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125a5c2bb6413a30c198449d8df0633eed5a"></a>INTEGRATIONSCHEME_LINEAR_EXPLICIT_EULER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125a1ed293a0fed9d092b99c54950609906e"></a>INTEGRATIONSCHEME_MODIFIED_EXPLICIT_EULER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125afeb6fc8d45cd54031dff437471249b2e"></a>INTEGRATIONSCHEME_LINEAR_MODIFIED_EXPLICIT_EULER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125ae740042b3568364f8c0eb641e2ddc242"></a>INTEGRATIONSCHEME_IMPLICIT_EULER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125a924238ecbed25e98bd10d72e2a152d15"></a>INTEGRATIONSCHEME_LINEAR_IMPLICIT_EULER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125a462a3cbe5c697b43bc6e9cd66e637970"></a>INTEGRATIONSCHEME_RUNGE_KUTTA_4&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9658a7cc17cc4b6f3d8accf2a8070125ab75f33aeff7a99ccb3ed30b5a9c4bd95"></a>INTEGRATIONSCHEME_LINEAR_RUNGE_KUTTA_4&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844">SurgSim::Math::MlcpConstraintType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844ac2bbb7a57ed35297239882c88fa9a311"></a>MLCP_INVALID_CONSTRAINT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844a5462335804811ec4e30d263eb62276a2"></a>MLCP_BILATERAL_1D_CONSTRAINT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844ad30ae3e813b205623676f6419b78d1b0"></a>MLCP_BILATERAL_2D_CONSTRAINT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844aff8510545b979ae36ff505a17a81275a"></a>MLCP_BILATERAL_3D_CONSTRAINT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844ab04116b46bb643cf13ba701321ebbbeb"></a>MLCP_UNILATERAL_3D_FRICTIONLESS_CONSTRAINT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844abd27e398840d299ad094f35c99a5339b"></a>MLCP_UNILATERAL_3D_FRICTIONAL_CONSTRAINT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844a7a889c9d3890b1934a2a0ff61aed4d9d"></a>MLCP_BILATERAL_FRICTIONLESS_SLIDING_CONSTRAINT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844a477fb71022bc3f65f39fb42d6e193ce6"></a>MLCP_BILATERAL_FRICTIONAL_SLIDING_CONSTRAINT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a76863af6f5e08e63c418a070ecb7e844a31beb6be0fc5dec3b79639a7fa5ce1c3"></a>MLCP_NUM_CONSTRAINT_TYPES&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a411443fa5506f17c068f9ce5f3132fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSurgSim_1_1Math.html#a411443fa5506f17c068f9ce5f3132fb3">SurgSim::Math::ShapeDirection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type defining the shape direction for certain templatized shape (i.e. </p>
<p><a class="el" href="classSurgSim_1_1Math_1_1CylinderShape.html" title="Cylinder shape: centered on (0 0 0), aligned along Y, defined with length and radius. ">CylinderShape</a> and <a class="el" href="classSurgSim_1_1Math_1_1CapsuleShape.html" title="Capsule shape: centered on (0, 0, 0), aligned along Y, with length and radius. ">CapsuleShape</a>) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a411443fa5506f17c068f9ce5f3132fb3a2b10edc494ea49d04d0edd4deec77072"></a>SHAPE_DIRECTION_AXIS_X&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a411443fa5506f17c068f9ce5f3132fb3a06a3ea0b7f95031b99ffcdf5e84fd1c6"></a>SHAPE_DIRECTION_AXIS_Y&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a411443fa5506f17c068f9ce5f3132fb3a1af4c5ca53d9e606007edfee409d0e89"></a>SHAPE_DIRECTION_AXIS_Z&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSurgSim_1_1Math.html#aaae1cfcc0a19a1ab8b923ff8fa41b437">SurgSim::Math::ShapeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixed List of enums for the available <a class="el" href="classSurgSim_1_1Math_1_1Shape.html" title="Generic rigid shape class defining a shape. ">Shape</a> types, do not explicitly assign values, ShapeCount is used to determine the number of actual shape types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437ac4b909b9a4baa382f82170a51b863ced"></a>SHAPE_TYPE_NONE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437a2bbc57f3ac6e6c62fd741de261b0cba1"></a>SHAPE_TYPE_BOX&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437a2f758b697b57c7dbddb6c72a120dc2eb"></a>SHAPE_TYPE_CAPSULE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437a2fb5ac94bea29ac1db26744158c2a025"></a>SHAPE_TYPE_CYLINDER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437a1176c995ee30f77a67e05b649512d52c"></a>SHAPE_TYPE_DOUBLESIDEDPLANE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437aba359609fcbf6afa38184ebc1de41249"></a>SHAPE_TYPE_MESH&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437a0b40cff2368a2c81ca0c82a3b1185ce2"></a>SHAPE_TYPE_OCTREE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437a01fb91151e39549aa233e8369220fca1"></a>SHAPE_TYPE_PLANE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437ab976c25d1c304070d01ca73e6df2a04d"></a>SHAPE_TYPE_SPHERE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437aada0b15e3aef6bfd2b7ab01337a69a31"></a>SHAPE_TYPE_SURFACEMESH&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaae1cfcc0a19a1ab8b923ff8fa41b437afe83ee1344ac061d09b6714e23e1937d"></a>SHAPE_TYPE_COUNT&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="add7be385e098d4c5bd8cc9d0bd720e1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class SubMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::addSubMatrix </td>
          <td>(</td>
          <td class="paramtype">const SubMatrix &amp;&#160;</td>
          <td class="paramname"><em>subMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockIdRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockIdCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSizeRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSizeCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to add a sub-matrix into a matrix, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>The matrix type </td></tr>
    <tr><td class="paramname">SubMatrix</td><td>The sub-matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">subMatrix</td><td>The sub-matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockIdRow,blockIdCol</td><td>The block indices in matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockSizeRow,blockSizeCol</td><td>The block size (size of the sub-matrix) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The matrix to add the sub-matrix into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a176e571983ce1dff3f5d14d8172942cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class SubMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::addSubMatrix </td>
          <td>(</td>
          <td class="paramtype">const SubMatrix &amp;&#160;</td>
          <td class="paramname"><em>subMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>blockIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to add a sub-matrix made of squared-blocks into a matrix, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>The matrix type </td></tr>
    <tr><td class="paramname">SubMatrix</td><td>The sub-matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">subMatrix</td><td>The sub-matrix (containing all the squared-blocks) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockIds</td><td>Vector of block indices (for accessing matrix) corresponding to the blocks in sub-matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockSize</td><td>The blocks size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The matrix to add the sub-matrix blocks into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad68e540a33a0fffb833c0e52e0ba4aa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector , class SubVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::addSubVector </td>
          <td>(</td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>subVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector *&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to add a sub-vector into a vector, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>The vector type </td></tr>
    <tr><td class="paramname">SubVector</td><td>The sub-vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">subVector</td><td>The sub-vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockId</td><td>The block index in vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockSize</td><td>The block size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vector</td><td>The vector to add the sub-vector into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a316d75fb1c95bd6de686e107cc96f813"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector , class SubVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::addSubVector </td>
          <td>(</td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>subVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>blockIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector *&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to add a sub-vector per block into a vector, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>The vector type </td></tr>
    <tr><td class="paramname">SubVector</td><td>The sub-vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">subVector</td><td>The sub-vector (containing all the blocks) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockIds</td><td>Vector of block indices (for accessing vector) corresponding to the blocks in sub-vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockSize</td><td>The block size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vector</td><td>The vector to add the sub-vector blocks into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa04ec545252017ab2d3e4a1e8409dcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::barycentricCoordinates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>coordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the barycentric coordinates of a point with respect to a triangle. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The normal must be unit length </dd>
<dd>
The triangle vertices must be in counter clockwise order in respect to the normal </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pt</td><td>Vertex of the point. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tv0,tv1,tv2</td><td>Vertices of the triangle in counter clockwise order in respect to the normal. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tn</td><td>Normal of the triangle (yes must be of norm 1 and a,b,c CCW). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coordinates</td><td>Barycentric coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true on success, false if two or more if the triangle is considered degenerate </dd></dl>

</div>
</div>
<a class="anchor" id="a0706fbe5ed3468facd6ccd16286bf787"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::barycentricCoordinates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>coordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the barycentric coordinates of a point with respect to a triangle. </p>
<p>Please note that each time you use this call the normal of the triangle will be calculated, if you convert more than one coordinate against this triangle, precalculate the normal and use the other version of this function </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pt</td><td>Vertex of the point. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tv0,tv1,tv2</td><td>Vertices of the triangle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coordinates</td><td>The Barycentric coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true on success, false if two or more if the triangle is considered degenerate </dd></dl>

</div>
</div>
<a class="anchor" id="a5b46381ac5e692962fbe55b6f4f96c61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int VOpt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::buildOrthonormalBasis </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to construct an orthonormal basis (i, j, k) given the 1st vector direction. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for the vector argument. Can usually be deduced. </td></tr>
    <tr><td class="paramname">VOpt</td><td>the option flags (alignment etc.) used for the vector argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">i</td><td>Should provide the 1st direction on input. The 1st vector of the basis (i, j, k) on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">j,k</td><td>The 2nd and 3rd orthonormal vectors of the basis (i, j, k) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if (i, j, k) has been built successfully, False if 'i' is a (or close to a) null vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If any of the parameter is a nullptr, an exception will be raised </dd></dl>

</div>
</div>
<a class="anchor" id="a30ba7f07ccda85f48033405f9dad88b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::calculateContactTriangleTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>penetrationDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>penetrationPoint0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>penetrationPoint1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>contactNormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the contact between two triangles. </p>
<p>Algorithm presented in <a href="https://docs.google.com/a/simquest.com/document/d/11ajMD7QoTVelT2_szGPpeUEY0wHKKxW1TOgMe8k5Fsc/pub">https://docs.google.com/a/simquest.com/document/d/11ajMD7QoTVelT2_szGPpeUEY0wHKKxW1TOgMe8k5Fsc/pub</a>. If the triangle are known to intersect, the deepest penetration of the triangles into each other is calculated. The triangle which penetrates less into the other triangle is chosen as contact. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t0v0,t0v1,t0v2</td><td>Vertices of the first triangle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t1v0,t1v1,t1v2</td><td>Vertices of the second triangle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t0n</td><td>Unit length normal of the first triangle, should be normalized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t1n</td><td>Unit length normal of the second triangle, should be normalized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">penetrationDepth</td><td>The depth of penetration. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">penetrationPoint0</td><td>The contact point on triangle0 (t0v0,t0v1,t0v2). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">penetrationPoint1</td><td>The contact point on triangle1 (t1v0,t1v1,t1v2). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contactNormal</td><td>The contact normal that points from triangle1 to triangle0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if intersection is detected. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The [out] params are not modified if there is no intersection. </dd>
<dd>
If penetrationPoint0 is moved by (contactNormal*penetrationDepth*0.5) and penetrationPoint1 is moved by -(contactNormal*penetrationDepth*0.5), the triangles will no longer be intersecting. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ef86a4800f30ac476b0a9e7f8195129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::calculateContactTriangleTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>penetrationDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>penetrationPoint0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>penetrationPoint1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>contactNormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the contact between two triangles. </p>
<p>Algorithm presented in <a href="https://docs.google.com/a/simquest.com/document/d/11ajMD7QoTVelT2_szGPpeUEY0wHKKxW1TOgMe8k5Fsc/pub">https://docs.google.com/a/simquest.com/document/d/11ajMD7QoTVelT2_szGPpeUEY0wHKKxW1TOgMe8k5Fsc/pub</a>. If the triangle are known to intersect, the deepest penetration of the triangles into each other is calculated. The triangle which penetrates less into the other triangle is chosen as contact. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t0v0,t0v1,t0v2</td><td>Vertices of the first triangle, should be normalized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t1v0,t1v1,t1v2</td><td>Vertices of the second triangle, should be normalized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">penetrationDepth</td><td>The depth of penetration. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">penetrationPoint0</td><td>The contact point on triangle0 (t0v0,t0v1,t0v2). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">penetrationPoint1</td><td>The contact point on triangle1 (t1v0,t1v1,t1v2). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contactNormal</td><td>The contact normal that points from triangle1 to triangle0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if intersection is detected. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The [out] params are not modified if there is no intersection. </dd>
<dd>
If penetrationPoint0 is moved by (contactNormal*penetrationDepth*0.5) and penetrationPoint1 is moved by -(contactNormal*penetrationDepth*0.5), the triangles will no longer be intersecting. </dd></dl>

</div>
</div>
<a class="anchor" id="a92db114456cae24f4f99f865dbab7a57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int QOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::computeAngle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T, QOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the angle corresponding to a quaternion's rotation, in radians. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">QOpt</td><td>the option flags (alignment etc.) used for the quaternion argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>the rotation quaternion to inspect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle of the rotation within [0 +pi], in radians. </dd></dl>

</div>
</div>
<a class="anchor" id="aa27356ff42fbf064f5e061d07bbc4654"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::computeAngle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 3, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the angle corresponding to a quaternion's rotation, in radians. </p>
<p>If you don't care about the rotation axis, this is more efficient than <a class="el" href="namespaceSurgSim_1_1Math.html#a4f21f5fb9c9297a330a1a48da586ae63" title="Get the angle (in radians) and axis corresponding to a rotation matrix. ">computeAngleAndAxis()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">MOpt</td><td>the option flags (alignment etc.) used for the rotation matrix argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the rotation matrix to inspect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle of the rotation, in radians. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a27b656526e7ee9c22691100afb375d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int QOpt, int VOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::computeAngleAndAxis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T, QOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the angle (in radians) and axis corresponding to a quaternion's rotation. </p>
<dl class="section note"><dt>Note</dt><dd>Unit quaternions cover the unit sphere twice (q=-q). To make sure that the same rotation (q or -q) </dd>
<dd>
returns the same Axis/Angle, we need a pi range for the angle. </dd>
<dd>
We choose to enforce half the angle in the quadrant [0 +pi/2], which leads to an output angle in [0 +pi]. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">QOpt</td><td>the option flags (alignment etc.) used for the quaternion argument. Can be deduced. </td></tr>
    <tr><td class="paramname">VOpt</td><td>the option flags (alignment etc.) used for the axis vector argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">quaternion</td><td>the rotation quaternion to inspect. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angle</td><td>the angle of the rotation in [0 +pi], in radians. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">axis</td><td>the axis of the rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f21f5fb9c9297a330a1a48da586ae63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int MOpt, int VOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::computeAngleAndAxis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 3, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the angle (in radians) and axis corresponding to a rotation matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">MOpt</td><td>the option flags (alignment etc.) used for the rotation matrix argument. Can be deduced. </td></tr>
    <tr><td class="paramname">VOpt</td><td>the option flags (alignment etc.) used for the axis vector argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>the rotation matrix to inspect. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angle</td><td>the angle of the rotation, in radians. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">axis</td><td>the axis of the rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fbc7a1a85731d1a9a74c293054eb77a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int TOpt, int VOpt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::computeRotationVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; T, 3, Eigen::Isometry, TOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; T, 3, Eigen::Isometry, TOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, VOpt &gt; *&#160;</td>
          <td class="paramname"><em>rotationVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the vector corresponding to the rotation between transforms. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">TOpt</td><td>the option flags (alignment etc.) used for the transform arguments. Can be deduced. </td></tr>
    <tr><td class="paramname">VOpt</td><td>the option flags (alignment etc.) used for the vector argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>the transform after the rotation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>the transform before the rotation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rotationVector</td><td>a vector describing the rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50d6115addb1846b588e6f9d28ad30d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distanceLineLine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>l0v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>l0v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>l1v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>l1v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>pt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>pt1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the distance between two lines. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">l0v0,l0v1</td><td>Points on Line 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">l1v0,l1v1</td><td>Points on Line 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pt0</td><td>The closest point on line 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pt1</td><td>The closest point on line 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normal distance between the two given lines i.e. (pt0 - pt1).norm() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We are using distancePointSegment for the degenerate cases as opposed to distancePointLine, why is that ??? (HS-2013-apr-26) </dd></dl>

</div>
</div>
<a class="anchor" id="af8e2a98a94db7ce8e9c84e196bae35fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distancePointLine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the normal distance between a point and a line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pt</td><td>The input point. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v0,v1</td><td>Two vertices on the line. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The point projected onto the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normal distance between the point and the line </dd></dl>

</div>
</div>
<a class="anchor" id="a63337c2b76e510312f48c8cf2b671bbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distancePointPlane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the distance of a point to a plane. </p>
<dl class="section pre"><dt>Precondition</dt><dd>n needs to the normalized </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pt</td><td>The point to check. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>The normal of the plane n (normalized). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">d</td><td>Constant d for the plane equation as in n.x + d = 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Projection of point p into the plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance to the plane (negative if on the backside of the plane). </dd></dl>

</div>
</div>
<a class="anchor" id="a35475dc04729dbe1fb485df92a29866e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distancePointSegment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Point segment distance, if the projection of the closest point is not within the segments, the closest segment point is used for the distance calculation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pt</td><td>The input point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sv0,sv1</td><td>The segment extremities. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Either the projection onto the segment or one of the 2 vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance of the point from the segment. </dd></dl>

</div>
</div>
<a class="anchor" id="adf836d6fcf8a0d8b572c162de1cb1358"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distancePointTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the normal distance of a point from a triangle, the resulting point will be on the edge of the triangle if the projection of the point is not inside the triangle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pt</td><td>The point that is being measured. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tv0,tv1,tv2</td><td>The vertices of the triangle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The point on the triangle that is closest to pt, if the projection of pt onto the triangle. plane is not inside the triangle the closest point on the edge will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the point and the triangle, i.e (result - pt).norm() </dd></dl>

</div>
</div>
<a class="anchor" id="a2635a405b157e933c75c7801037a1635"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distanceSegmentPlane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>closestPointSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>planeIntersectionPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the distance between a segment and a plane. </p>
<dl class="section pre"><dt>Precondition</dt><dd>n should be normalized </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sv0,sv1</td><td>Endpoints of the segments. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Normal of the plane n (normalized). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">d</td><td>Constant d in n.x + d = 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closestPointSegment</td><td>Point closest to the plane, the midpoint of the segment (v0+v1)/2 is being used if the segment is parallel to the plane. If the segment actually intersects the plane segmentIntersectionPoint will be equal to planeIntersectionPoint. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">planeIntersectionPoint</td><td>the point on the plane where the line defined by the segment intersects the plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance of closest point of the segment to the plane, 0 if the segment intersects the plane, negative if the closest point is on the other side of the plane. </dd></dl>

</div>
</div>
<a class="anchor" id="a00cd05c651b56d43baaeb5aaa488698f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distanceSegmentSegment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>s0v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>s0v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>pt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s0t</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>s1t</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distance between two segments, if the project of the closest point is not on the opposing segment, the segment endpoints will be used for the distance calculation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">s0v0,s0v1</td><td>Segment 0 Extremities. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">s1v0,s1v1</td><td>Segment 1 Extremities. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pt0</td><td>Closest point on segment 0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pt1</td><td>Closest point on segment 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s0t</td><td>Abscissa at the point of intersection on Segment 0 (s0v0 + t * (s0v1 - s0v0)). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s1t</td><td>Abscissa at the point of intersection on Segment 0 (s1v0 + t * (s1v1 - s1v0)). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance between the segments, i.e. (pt0 - pt1).norm() </dd></dl>

</div>
</div>
<a class="anchor" id="abf0a4678f7e9c87ccc972967ee75cfa7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distanceSegmentTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>segmentPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>trianglePoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the distance of a line segment to a triangle. </p>
<p>Note that this version will calculate the normal of the triangle, if the normal is known use the other version of this function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sv0,sv1</td><td>Extremities of the line segment. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tv0,tv1,tv2</td><td>Triangle points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentPoint</td><td>Closest point on the segment. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">trianglePoint</td><td>Closest point on the triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the the distance between the two closest points, i.e. (trianglePoint - segmentPoint).norm(). </dd></dl>

</div>
</div>
<a class="anchor" id="a8758111b69f11c1ab4335295f0865792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distanceSegmentTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>segmentPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>trianglePoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the distance of a line segment to a triangle. </p>
<dl class="section pre"><dt>Precondition</dt><dd>n needs to be normalized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sv0,sv1</td><td>Extremities of the line segment. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tv0,tv1,tv2</td><td>Points of the triangle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">normal</td><td>Normal of the triangle (Expected to be normalized) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segmentPoint</td><td>Closest point on the segment. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">trianglePoint</td><td>Closest point on the triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the two closest points. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c3c760a9ae9f59b36779dbf8f94cef3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distanceTrianglePlane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>closestPointTriangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>planeProjectionPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the distance of a triangle to a plane. </p>
<dl class="section pre"><dt>Precondition</dt><dd>n should be normalized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tv0,tv1,tv2</td><td>Points of the triangle. </td></tr>
    <tr><td class="paramname">n</td><td>Normal of the plane n (normalized). </td></tr>
    <tr><td class="paramname">d</td><td>Constant d in n.x + d = 0. </td></tr>
    <tr><td class="paramname">closestPointTriangle</td><td>Closest point on the triangle, when the triangle is coplanar to the plane (tv0+tv1+tv2)/3 is used, when the triangle intersects the plane the midpoint of the intersection segment is returned. </td></tr>
    <tr><td class="paramname">planeProjectionPoint</td><td>Projection of the closest point onto the plane, when the triangle intersects the plane the midpoint of the intersection segment is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance of the triangle to the plane. </dd></dl>

</div>
</div>
<a class="anchor" id="a849c7d7236824c7d00ffbe0238d408d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SurgSim::Math::distanceTriangleTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>closestPoint0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>closestPoint1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the distance between two triangles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t0v0,t0v1,t0v2</td><td>Points of the first triangle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t1v0,t1v1,t1v2</td><td>Points of the second triangle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closestPoint0</td><td>Closest point on the first triangle, unless penetrating, in which case it is the point along the edge that allows min separation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closestPoint1</td><td>Closest point on the second triangle, unless penetrating, in which case it is the point along the edge that allows min separation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the two triangles. </dd></dl>

</div>
</div>
<a class="anchor" id="ac70085ba6ead5d388aa603ee30e02f53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::doAabbIntersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AlignedBox&lt; Scalar, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>aabb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AlignedBox&lt; Scalar, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>aabb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether two AABBs have an intersection with each other, for the calculation see <a href="http://www.gamasutra.com/view/feature/131790/simple_intersection_tests_for_games.php?page=3">http://www.gamasutra.com/view/feature/131790/simple_intersection_tests_for_games.php?page=3</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>numeric type </td></tr>
    <tr><td class="paramname">Dim</td><td>dimension of the space to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aabb0</td><td>first axis aligned bounding box </td></tr>
    <tr><td class="paramname">aabb1</td><td>second axis aligned bounding box </td></tr>
    <tr><td class="paramname">tolerance</td><td>the bounding boxes will be considered bigger by this amount </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is an overlap between the two boxes </dd></dl>

</div>
</div>
<a class="anchor" id="af6485f8667bd89df354e65ba872970d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int Dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::doAabbIntersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AlignedBox&lt; Scalar, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AlignedBox&lt; Scalar, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether two AABBs overlap, using a minimal set of eigen calls, does not take a tolerance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>numeric type </td></tr>
    <tr><td class="paramname">Dim</td><td>dimension of the space to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first axis aligned bounding box </td></tr>
    <tr><td class="paramname">b</td><td>second axis aligned bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is an overlap between the two boxes </dd></dl>

</div>
</div>
<a class="anchor" id="ad3350b166fcff3495bcd97a04a22873a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::doesCollideSegmentTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the intersection of a line segment with a triangle See <a href="http://geomalgorithms.com/a06-_intersect-2.html#intersect_RayTriangle">http://geomalgorithms.com/a06-_intersect-2.html#intersect_RayTriangle</a> for the algorithm. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The normal must be unit length </dd>
<dd>
The triangle vertices must be in counter clockwise order in respect to the normal </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sv0,sv1</td><td>Extremities of the segment. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tv0,tv1,tv2</td><td>The triangle vertices. CCW around the normal. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tn</td><td>The triangle normal, should be normalized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The point where the triangle and the line segment intersect, invalid if they don't intersect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the segment intersects with the triangle, false if it does not </dd></dl>
<dl class="section note"><dt>Note</dt><dd>HS-2013-may-07 This is the only function that only checks for intersection rather than returning a distance if necessary this should be rewritten to do the distance calculation, doing so would necessitate to check against all the triangle edges in the non intersection cases. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2071a58948bbe0b4c1ea3d720926019"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::doesIntersectBoxCapsule </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>capsuleBottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>capsuleTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>capsuleRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AlignedBox&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if an axis aligned box intersects with a capsule. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capsuleBottom</td><td>Position of the capsule bottom </td></tr>
    <tr><td class="paramname">capsuleTop</td><td>Position of the capsule top </td></tr>
    <tr><td class="paramname">capsuleRadius</td><td>The capsule radius </td></tr>
    <tr><td class="paramname">box</td><td>Axis aligned bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if intersection is detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a447f61cf175f70a9c9d0cf854bd1cdd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::doesIntersectPlanePlane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pn0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>pd0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>pd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>pt0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1, MOpt &gt; *&#160;</td>
          <td class="paramname"><em>pt1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if two planes are intersecting, if yes also calculate the intersection line. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pn0,pd0</td><td>Normal and constant of the first plane, nx + d = 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pn1,pd1</td><td>Normal and constant of the second plane, nx + d = 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pt0,pt1</td><td>Two points on the intersection line, not valid if there is no intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when a unique line exists, false for disjoint or coinciding. </dd></dl>

</div>
</div>
<a class="anchor" id="add58a64be0b70e6c82a3941ca1d09a88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::doesIntersectTriangleTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the two triangles intersect using separating axis test. </p>
<p>Algorithm is implemented from <a href="http://fileadmin.cs.lth.se/cs/Personal/Tomas_Akenine-Moller/pubs/tritri.pdf">http://fileadmin.cs.lth.se/cs/Personal/Tomas_Akenine-Moller/pubs/tritri.pdf</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0v0,t0v1,t0v2</td><td>Vertices of the first triangle. </td></tr>
    <tr><td class="paramname">t1v0,t1v1,t1v2</td><td>Vertices of the second triangle. </td></tr>
    <tr><td class="paramname">t0n</td><td>Normal of the first triangle, should be normalized. </td></tr>
    <tr><td class="paramname">t1n</td><td>Normal of the second triangle, should be normalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if intersection is detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b62c761e8886957c058713bf0a46562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::doesIntersectTriangleTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the two triangles intersect using separating axis test. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0v0,t0v1,t0v2</td><td>Vertices of the first triangle. </td></tr>
    <tr><td class="paramname">t1v0,t1v1,t1v2</td><td>Vertices of the second triangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if intersection is detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a689366956d4a4dceee90eafc337e73bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::edgeIntersection </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>pvStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>pvEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>parametricIntersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>parametricIntersectionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two ends of the triangle edge are given in terms of the following vertex properties. </p>
<ul>
<li>Signed distance from the colliding triangle.</li>
<li>Projection on the separating axis. Get the intersection of this edge and the plane in terms of the projection on the separating axis. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dStart</td><td>Signed distance of the start of edge from the plane of the colliding triangle. </td></tr>
    <tr><td class="paramname">dEnd</td><td>Signed distance of the end of edge from the plane of the colliding triangle. </td></tr>
    <tr><td class="paramname">pvStart</td><td>Projection of the start of edge from the plane of the colliding triangle. </td></tr>
    <tr><td class="paramname">pvEnd</td><td>Projection of the end of edge from the plane of the colliding triangle. </td></tr>
    <tr><td class="paramname">parametricIntersection</td><td>Parametric representation of the intersection between the triangle edge and the plane in terms of the projection on the separating axis. </td></tr>
    <tr><td class="paramname">parametricIntersectionIndex</td><td>The array index of parametricIntersection. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a0a23aa103fcbc4d5381d8a473f54de78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SurgSim::Math::getMlcpConstraintTypeName </td>
          <td>(</td>
          <td class="paramtype">MlcpConstraintType&#160;</td>
          <td class="paramname"><em>constraintType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afdaa333f24a25241844b3a2e6bac7396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSurgSim_1_1Math.html#a76863af6f5e08e63c418a070ecb7e844">MlcpConstraintType</a> SurgSim::Math::getMlcpConstraintTypeValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8fb4b9567782673f3f932980b40c73d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Block&lt;<a class="el" href="namespaceSurgSim_1_1Math.html#a09630a3dd9bc5c78f9a68a313e4582ab">Matrix</a>&gt; SurgSim::Math::getSubMatrix </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockIdRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockIdCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSizeRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSizeCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to access a sub-matrix from a matrix, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>The matrix type to get the sub-matrix from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to get the sub-matrix from </td></tr>
    <tr><td class="paramname">blockIdRow,blockIdCol</td><td>The block indices </td></tr>
    <tr><td class="paramname">blockSizeRow,blockSizeCol</td><td>The block size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested sub-matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Disable cpplint warnings for use of non-const reference </dd>
<dd>
<a class="el" href="namespaceEigen.html">Eigen</a> has a specific type for Block that we want to return with read/write access </dd>
<dd>
therefore the Matrix from which the Block is built from must not be const </dd></dl>

</div>
</div>
<a class="anchor" id="adf1b1178f052b4ae1a1af19e581c8e49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespaceSurgSim_1_1Math.html#ad0bac671a4eb2e7e762ac8b836e941a7">Vector</a>&gt; SurgSim::Math::getSubVector </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to access a sub-vector from a vector, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>The vector type to get the sub-vector from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The vector to get the sub-vector from </td></tr>
    <tr><td class="paramname">blockId</td><td>The block index </td></tr>
    <tr><td class="paramname">blockSize</td><td>The block size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested sub-vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Disable cpplint warnings for use of non-const reference </dd>
<dd>
<a class="el" href="namespaceEigen.html">Eigen</a> has a specific type for VectorBlock that we want to return with read/write access </dd>
<dd>
therefore the Vector from which the VectorBlock is built from must not be const </dd></dl>

</div>
</div>
<a class="anchor" id="abaf898c8281825775e047559511eddae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector , class SubVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::getSubVector </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>blockIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubVector *&#160;</td>
          <td class="paramname"><em>subVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to get a sub-vector per block from a vector, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>The vector type </td></tr>
    <tr><td class="paramname">SubVector</td><td>The sub-vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vector</td><td>The vector (containing the blocks in a sparse manner) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockIds</td><td>Vector of block indices (for accessing vector) corresponding to the blocks in vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockSize</td><td>The block size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subVector</td><td>The sub-vector to store the requested blocks (blockIds) from vector into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1530d6ee41d00de97a3dbe0187fbabd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int TOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Transform&lt;T, 3, Eigen::Isometry&gt; SurgSim::Math::interpolate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; T, 3, Eigen::Isometry, TOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; T, 3, Eigen::Isometry, TOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate (slerp) between 2 rigid transformations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">TOpt</td><td>the option flags (alignment etc.) used for the Transform arguments. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0</td><td>The start transform (at time 0.0). </td></tr>
    <tr><td class="paramname">t1</td><td>The end transform (at time 1.0). </td></tr>
    <tr><td class="paramname">t</td><td>The interpolation time requested. Within [0..1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transform resulting in the slerp interpolation at time t, between t0 and t1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>t=0 =&gt; returns t0 </dd>
<dd>
t=1 =&gt; returns t1 </dd></dl>

</div>
</div>
<a class="anchor" id="af497ebd6ee555a1dfcdff2cfba26d422"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int QOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;T, QOpt&gt; SurgSim::Math::interpolate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T, QOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; T, QOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolate (slerp) between 2 quaternions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">QOpt</td><td>the option flags (alignment etc.) used for the quaternion arguments. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q0</td><td>The start quaternion (at time 0.0). </td></tr>
    <tr><td class="paramname">q1</td><td>The end quaternion (at time 1.0). </td></tr>
    <tr><td class="paramname">t</td><td>The interpolation time requested. Within [0..1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quaternion resulting in the slerp interpolation at time t, between q0 and q1. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>t=0 =&gt; returns either q0 or -q0 </dd>
<dd>
t=1 =&gt; returns either q1 or -q1 </dd>
<dd>
'Interpolate' has been created because slerp might not be enough in certain cases. This gives room for correction and special future treatment </dd></dl>

</div>
</div>
<a class="anchor" id="a6a9b5ba71a0dbd8d53d44e09f4a27d70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int size, int TOpt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, size, 1, TOpt&gt; SurgSim::Math::interpolate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, size, 1, TOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, size, 1, TOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate (slerp) between 2 vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">size</td><td>the size of the vectors. Can be deduced. </td></tr>
    <tr><td class="paramname">TOpt</td><td>the option flags (alignment etc.) used for the Vector arguments. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous</td><td>The starting vector (at time 0.0). </td></tr>
    <tr><td class="paramname">next</td><td>The ending vector (at time 1.0). </td></tr>
    <tr><td class="paramname">t</td><td>The interpolation time requested. Within [0..1], although note bounds are not checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transform resulting in the slerp interpolation at time t. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>t=0 =&gt; returns vector 'previous' </dd>
<dd>
t=1 =&gt; returns vector 'next' </dd></dl>

</div>
</div>
<a class="anchor" id="a681860a95cf954659d67a644e44ba52d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::intersectionsSegmentBox </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AlignedBox&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &gt; *&#160;</td>
          <td class="paramname"><em>intersections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the intersections between a line segment and an axis aligned box. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sv0,sv1</td><td>Extremities of the line segment. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">box</td><td>Axis aligned bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersections</td><td>The points of intersection between the segment and the box </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a482bca6dd2b244858c10c4dbd053b549"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isCoplanar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the points are coplanar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b,c,d</td><td>Points to check for coplanarity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the points are coplanar. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0cb197b6c0c0f9605be3cf86c12d9d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isPointInsideTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is inside a triangle. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="namespaceSurgSim_1_1Math.html#aaa04ec545252017ab2d3e4a1e8409dcf" title="Calculate the barycentric coordinates of a point with respect to a triangle. ">barycentricCoordinates()</a> if you need the coordinates </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The normal must be unit length </dd>
<dd>
The triangle vertices must be in counter clockwise order in respect to the normal </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>Vertex of the point. </td></tr>
    <tr><td class="paramname">tv0,tv1,tv2</td><td>Vertices of the triangle, must be in CCW. </td></tr>
    <tr><td class="paramname">tn</td><td>Normal of the triangle (yes must be of norm 1 and a,b,c CCW). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pt lies inside the triangle tv0, tv1, tv2, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af84c69f2f8a08233f9fe9df2efa10f2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isPointInsideTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>tv2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a point is inside a triangle. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="namespaceSurgSim_1_1Math.html#aaa04ec545252017ab2d3e4a1e8409dcf" title="Calculate the barycentric coordinates of a point with respect to a triangle. ">barycentricCoordinates()</a> if you need the coordinates. Please note that the normal will be calculated each time you use this call, if you are doing more than one test with the same triangle, precalculate the normal and pass it. Into the other version of this function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Accuracy of the calculation, can usually be inferred. </td></tr>
    <tr><td class="paramname">MOpt</td><td><a class="el" href="namespaceEigen.html">Eigen</a> Matrix options, can usually be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>Vertex of the point. </td></tr>
    <tr><td class="paramname">tv0,tv1,tv2</td><td>Vertices of the triangle, must be in CCW. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pt lies inside the triangle tv0, tv1, tv2, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adc08ae33d45df0ba04f01272b9af7460"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isSubnormal </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <code>float</code> value is subnormal. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;float&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;float&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if subnormal; false if not (normal, zero, infinite or NaN). </dd></dl>

</div>
</div>
<a class="anchor" id="a5f417e355801b7df0774434dd87f1b43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isSubnormal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <code>double</code> value is subnormal. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;double&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;double&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if subnormal; false if not (normal, zero, infinite or NaN). </dd></dl>

</div>
</div>
<a class="anchor" id="a200bb06ccdc27f5e465a46c61aae4088"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isSubnormal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a matrix or a vector contains any subnormal floating-point values. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the base type used to describe the matrix or vector. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the matrix or vector value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any value is subnormal; false if none are (i.e. each is normal, zero, infinite or NaN). </dd></dl>

</div>
</div>
<a class="anchor" id="a8ccd402f82d24ef14ef9c592a75d447a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isSubnormal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::QuaternionBase&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a quaternion contains any subnormal floating-point values. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the base type used to describe the quaternion. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the quaternion value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any value is subnormal; false if none are (i.e. each is normal, zero, infinite or NaN). </dd></dl>

</div>
</div>
<a class="anchor" id="a10777876a6a57a79e295762c2371c485"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isSubnormal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AngleAxis&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an angle/axis 3D rotation contains any subnormal floating-point values. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the scalar type used to describe the rotation. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the rotation value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any value is subnormal; false if none are (i.e. each is normal, zero, infinite or NaN). </dd></dl>

</div>
</div>
<a class="anchor" id="a592dab5be08b271d0646739139640878"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isSubnormal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Rotation2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a 2D rotation is described by an angle that is subnormal. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the scalar type used to describe the rotation. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 2D rotation value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the angle is subnormal; false if not (normal, zero, infinite or NaN). </dd></dl>

</div>
</div>
<a class="anchor" id="a6f99ae4252de135283d5ed75fb1a44b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int D, int M, int O&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isSubnormal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; T, D, M, O &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a transform contains any subnormal floating-point values. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the scalar type used to describe the transform. Can usually be deduced. </td></tr>
    <tr><td class="paramname">D</td><td>the dimension used to describe the transform. Can usually be deduced. </td></tr>
    <tr><td class="paramname">M</td><td>the mode value used to describe the transform. Can usually be deduced. </td></tr>
    <tr><td class="paramname">O</td><td>the options value used to describe the transform. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the transform value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any value is subnormal; false if none are (i.e. each is normal, zero, infinite or NaN). </dd></dl>

</div>
</div>
<a class="anchor" id="a7d999883903a13d9fbfae0d74c325c0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isValid </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <code>float</code> value is valid. </p>
<p>Zero, subnormal and normal numbers are valid; infinities and NaNs are not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a17b445f3e132e0711acc3a6d57a9dd22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isValid </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <code>double</code> value is valid. </p>
<p>Zero, subnormal and normal numbers are valid; infinities and NaNs are not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ab9333011ab42799f84f2dfe20a7c24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isValid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a matrix or a vector is valid. </p>
<p>These quantities are valid if all of their elements are valid. Zero, subnormal and normal numbers are valid; infinities and NaNs are not. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the base type used to describe the matrix or vector. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the matrix or vector value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a69dfef405ae8c4871a2f938d26b0468b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isValid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::QuaternionBase&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a quaternion is valid. </p>
<p>Quaternions are valid if all of their components are valid. Zero, subnormal and normal numbers are valid; infinities and NaNs are not. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the base type used to describe the quaternion. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the quaternion value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a137e9685c2d56d4956f7749f95f588c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isValid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AngleAxis&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an angle/axis 3D rotation is valid. </p>
<p>Angle/axis rotations are valid if the angle and the axis components are valid. Zero, subnormal and normal numbers are valid; infinities and NaNs are not. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the scalar type used to describe the rotation. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the rotation value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0887f0a4909704ad6c2af45203c9f57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isValid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Rotation2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a 2D rotation is valid. </p>
<p>2D rotations are valid if the rotation angle is valid. Zero, subnormal and normal numbers are valid; infinities and NaNs are not. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the scalar type used to describe the rotation. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the rotation value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d8b6235b40cee368631374231308661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int D, int M, int O&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::isValid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; T, D, M, O &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a transform is valid. </p>
<p>Transforms are valid if all of their components are valid. Zero, subnormal and normal numbers are valid; infinities and NaNs are not. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the scalar type used to describe the transform. Can usually be deduced. </td></tr>
    <tr><td class="paramname">D</td><td>the dimension used to describe the transform. Can usually be deduced. </td></tr>
    <tr><td class="paramname">M</td><td>the mode value used to describe the transform. Can usually be deduced. </td></tr>
    <tr><td class="paramname">O</td><td>the options value used to describe the transform. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the transform value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e1c2267da36b307694eb8a10f460799"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int Dim, int MType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AlignedBox&lt;Scalar, Dim&gt; SurgSim::Math::makeAabb </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Dim, 1, MType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Dim, 1, MType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Dim, 1, MType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for creating a bounding box from three vertices (e.g. </p>
<p>the vertices of a triangle) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>numeric type </td></tr>
    <tr><td class="paramname">Dim</td><td>dimension of the space to be used </td></tr>
    <tr><td class="paramname">MType</td><td>the eigen type of the vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an AABB containing all the points passed </dd></dl>

</div>
</div>
<a class="anchor" id="a3f3946fbd295cbf3342a6f4358ef9e3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Transform&lt;typename M::Scalar, M::RowsAtCompileTime, Eigen::Isometry&gt; SurgSim::Math::makeRigidTransform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rigid transform using the specified rotation matrix and translation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>the type used to describe the rotation matrix. Can usually be deduced. </td></tr>
    <tr><td class="paramname">V</td><td>the type used to describe the translation vector. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>the rotation matrix. </td></tr>
    <tr><td class="paramname">translation</td><td>the translation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transform with the specified rotation and translation. </dd></dl>

</div>
</div>
<a class="anchor" id="aab55abeabcca76fcd474927834d16d8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Transform&lt;typename Q::Scalar, 3, Eigen::Isometry&gt; SurgSim::Math::makeRigidTransform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::QuaternionBase&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rigid transform using the specified rotation quaternion and translation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>the type used to describe the rotation quaternion. Can usually be deduced. </td></tr>
    <tr><td class="paramname">V</td><td>the type used to describe the translation vector. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>the rotation quaternion. </td></tr>
    <tr><td class="paramname">translation</td><td>the translation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transform with the specified rotation and translation. </dd></dl>

</div>
</div>
<a class="anchor" id="a88989dc085efef2d9fdd92ea5ee38e37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Transform&lt;T, 3, Eigen::Isometry&gt; SurgSim::Math::makeRigidTransform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a rigid transform from a eye point a center view point and an up direction, does not check whether up is colinear with eye-center The original formula can be found at <a href="http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml">http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">typename</td><td>T T the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">int</td><td>VOpt VOpt the option flags (alignment etc.) used for the axis vector argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position of the object. </td></tr>
    <tr><td class="paramname">center</td><td>The point to which the object should point. </td></tr>
    <tr><td class="paramname">up</td><td>The up vector to be used for this calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a RigidTransform that locates the object at position rotated into the direction of center. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e7787cebfc5b479c219e1b34a53ce13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Transform&lt;typename V::Scalar, V::SizeAtCompileTime, Eigen::Isometry&gt; SurgSim::Math::makeRigidTranslation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rigid transform using the identity rotation and the specified translation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type used to describe the translation vector. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translation</td><td>the translation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transform with the identity rotation and the specified translation. </dd></dl>

</div>
</div>
<a class="anchor" id="a255fd32bc9937a9002db27fd9f4340ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 3, 3&gt; SurgSim::Math::makeRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rotation matrix corresponding to the specified angle (in radians) and axis. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">VOpt</td><td>the option flags (alignment etc.) used for the axis vector argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>the angle of the rotation, in radians. </td></tr>
    <tr><td class="paramname">axis</td><td>the axis of the rotation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotation matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="afbbf2dcddf489123bf60c75a6d347596"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;T&gt; SurgSim::Math::makeRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a quaternion rotation corresponding to the specified angle (in radians) and axis. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">VOpt</td><td>the option flags (alignment etc.) used for the axis vector argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>the angle of the rotation, in radians. </td></tr>
    <tr><td class="paramname">axis</td><td>the axis of the rotation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotation quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="a096cb6059be3c8cc153b7ca1aa38e875"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 3, 3&gt; SurgSim::Math::makeSkewSymmetricMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1, VOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a skew-symmetric matrix corresponding to the specified vector. </p>
<p>Skew-symmetric matrices are particularly useful for representing a portion of the vector cross-product. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">VOpt</td><td>the option flags (alignment etc.) used for the vector argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the vector to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the skew-symmetric matrix corresponding with the vector argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5101db9404f2a4bd8284ae6c5de1051"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int QOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;T, QOpt&gt; SurgSim::Math::negate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T, QOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quaternion negation (i.e. </p>
<p>unary operator -) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">QOpt</td><td>the option flags (alignment etc.) used for the quaternion arguments. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion to negate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the negation of q (i.e. -q) </dd></dl>

</div>
</div>
<a class="anchor" id="a3ac74c4216c96b3a89cc181fc2be3538"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class SubMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::setSubMatrix </td>
          <td>(</td>
          <td class="paramtype">const SubMatrix &amp;&#160;</td>
          <td class="paramname"><em>subMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockIdRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockIdCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSizeRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSizeCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to set a sub-matrix into a matrix, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>The matrix type </td></tr>
    <tr><td class="paramname">SubMatrix</td><td>The sub-matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">subMatrix</td><td>The sub-matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockIdRow,blockIdCol</td><td>The block indices for row and column in matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockSizeRow,blockSizeCol</td><td>The size of the sub-matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The matrix to set the sub-matrix into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8d5b1c4a9b3048a0eb2ae6225c64d79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::setSubnormalToZero </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the <code>float</code> value is subnormal, set it to zero. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;float&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;float&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>the value to check and possibly modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value was modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a233a2e972d0d3ba89c287f9615820792"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::setSubnormalToZero </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the <code>double</code> value is subnormal, set it to zero. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;double&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;double&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>the value to check and possibly modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value was modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a82d41f0aaac297fc06cbf95c4a06dfa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::setSubnormalToZero </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all subnormal values in a matrix or a vector to zero. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the base type used to describe the matrix or vector. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>the matrix or vector value to check and possibly modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any value was modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f58c4e6daec2d279a4911c8ab4d0183"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::setSubnormalToZero </td>
          <td>(</td>
          <td class="paramtype">Eigen::QuaternionBase&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all subnormal values in a quaternion to zero. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the base type used to describe the quaternion. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>the quaternion value to check and possibly modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any value was modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a62671eec2c1c9182efed516d77f3db1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::setSubnormalToZero </td>
          <td>(</td>
          <td class="paramtype">Eigen::AngleAxis&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all subnormal values in an angle/axis 3D rotation to zero. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the scalar type used to describe the rotation. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>the rotation value to check and possibly modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any value was modified. </dd></dl>

</div>
</div>
<a class="anchor" id="aebbd67f246c9cfda1afea747f99325a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::setSubnormalToZero </td>
          <td>(</td>
          <td class="paramtype">Eigen::Rotation2D&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the angle of a 2D rotation is subnormal, set it to zero. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the scalar type used to describe the rotation. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>the rotation value to check and possibly modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value was modified. </dd></dl>

</div>
</div>
<a class="anchor" id="af753cbd2ae10c85d0236c4d216a2819a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int D, int M, int O&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SurgSim::Math::setSubnormalToZero </td>
          <td>(</td>
          <td class="paramtype">Eigen::Transform&lt; T, D, M, O &gt; *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all subnormal values in a transform to zero. </p>
<p>Subnormal values have absolute values in the range <code>std::numeric_limits&lt;T&gt;::denorm_min() &lt;= x &lt; std::numeric_limits&lt;T&gt;::min()</code>, and can result in very slow floating point calculations under some conditions. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the base type used to describe the transform. Can usually be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value</td><td>the transform value to check and possibly modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any value was modified. </dd></dl>

</div>
</div>
<a class="anchor" id="acafb55af05cd84854fe69b9aeaeca367"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector , class SubVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SurgSim::Math::setSubVector </td>
          <td>(</td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>subVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector *&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to set a sub-vector into a vector, for the sake of clarity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>The vector type </td></tr>
    <tr><td class="paramname">SubVector</td><td>The sub-vector type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">subVector</td><td>The sub-vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockId</td><td>The block index in vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">blockSize</td><td>The size of the sub-vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vector</td><td>The vector to set the sub-vector into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37cbd55a53a75994beac2e002ec39d6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int MOpt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 3, 1&gt; SurgSim::Math::skew </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 3, MOpt &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the unique vector from the skew-symmetric part of a given matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric data type used for arguments and the return value. Can usually be deduced. </td></tr>
    <tr><td class="paramname">MOpt</td><td>the option flags (alignment etc.) used for the matrix argument. Can be deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the matrix to compute the skew symmetric part from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unique vector defining the skew-symmetric part of the matrix. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For any vector u, skew(makeSkewSymmetricMatrix(u)) = u </dd>
<dd>
In general, returns the vector of the skew symmetric part of matrix: (matrix - matrix^T)/2 </dd></dl>

</div>
</div>
<a class="anchor" id="a5cb6b7bb61aa50da1799b50e72e361ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1BoxShape.html">SurgSim::Math::BoxShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoxShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d680aa0e22a9f2dd091c22aacff5b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1CapsuleShape.html">SurgSim::Math::CapsuleShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CapsuleShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a62ec9148ef065742f2a0fe51625f476c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1PlaneShape.html">SurgSim::Math::PlaneShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlaneShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ffd80540b75e90ca3d0772bafe68f8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1SphereShape.html">SurgSim::Math::SphereShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SphereShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abac29757a5e84f10843be7c6dea0f3b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1CylinderShape.html">SurgSim::Math::CylinderShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CylinderShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5485c28dda48813b25912d404247fc9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1DoubleSidedPlaneShape.html">SurgSim::Math::DoubleSidedPlaneShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleSidedPlaneShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6fdff4fb4e711cc93b36e322bca8d4e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1OctreeShape.html">SurgSim::Math::OctreeShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OctreeShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3d77f496910642c6eb9524d75fba8867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1MeshShape.html">SurgSim::Math::MeshShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af38f99b9a7c90d81ba68540946da2020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_REGISTER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1Shape.html">SurgSim::Math::Shape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurgSim_1_1Math_1_1SurfaceMeshShape.html">SurgSim::Math::SurfaceMeshShape</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SurfaceMeshShape&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab31cbb9946189dfd4453018b1202e7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">PlaneShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2ca30c9560a55f658f45f723c9b18d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">CylinderShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a56e0fca2577ee1b6624f5f0d1f535ef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">DoubleSidedPlaneShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b44c7eb8e60c321741b349584a8cae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">SphereShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0339ae4326311b32debaf24e4cc83d16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">CapsuleShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae84c560b837920b5771866d6c2f37f33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">SurfaceMeshShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeced1b545d8bd65f3dba869641109e90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">BoxShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe5dbd42c0d7070684667bc9484882fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">OctreeShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f644cbf25cda3fd15c277a080531706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurgSim::Math::SURGSIM_STATIC_REGISTRATION </td>
          <td>(</td>
          <td class="paramtype">MeshShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ad8213a4e895f7ee0ddebd8a697d059c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 100 &gt; SurgSim::Math::gaussQuadrature100Points</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>100-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;, &lt;x_3, w_3&gt;, ..., &lt;x_100, w_100&gt;} </p>
<dl class="section note"><dt>Note</dt><dd>Gauss-Legendre quadrature numerically evaluates the integral of a function \(f\) with a finite sum using some weights and specific points of evaluation of the function \(f\): </dd>
<dd>
\(\int_{-1}^{+1} f(x) dx = \sum_{i=1}^n w_i f(x_i)\) </dd>
<dd>
n is the number of points used to discretized the integral </dd>
<dd>
\(x_i\) is the point to evaluate the function \(f\) with </dd>
<dd>
\(w_i\) is the weight to assign to the function evaluation at the given point \(x_i\) </dd></dl>

</div>
</div>
<a class="anchor" id="a988836fe863ef78265350fc669f105b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 1 &gt; SurgSim::Math::gaussQuadrature1Point</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1-point Gauss-Legendre quadrature {&lt;x_1, w_1&gt;} </p>
<dl class="section note"><dt>Note</dt><dd>Gauss-Legendre quadrature numerically evaluates the integral of a function \(f\) with a finite sum using some weights and specific points of evaluation of the function \(f\): </dd>
<dd>
\(\int_{-1}^{+1} f(x) dx = \sum_{i=1}^n w_i f(x_i)\) </dd>
<dd>
n is the number of points used to discretized the integral </dd>
<dd>
\(x_i\) is the point to evaluate the function \(f\) with </dd>
<dd>
\(w_i\) is the weight to assign to the function evaluation at the given point \(x_i\) </dd></dl>

</div>
</div>
<a class="anchor" id="aeafb88e552f9f5fa3a54a609e1c997c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 2 &gt; SurgSim::Math::gaussQuadrature2Points</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;} </p>
<dl class="section note"><dt>Note</dt><dd>Gauss-Legendre quadrature numerically evaluates the integral of a function \(f\) with a finite sum using some weights and specific points of evaluation of the function \(f\): </dd>
<dd>
\(\int_{-1}^{+1} f(x) dx = \sum_{i=1}^n w_i f(x_i)\) </dd>
<dd>
n is the number of points used to discretized the integral </dd>
<dd>
\(x_i\) is the point to evaluate the function \(f\) with </dd>
<dd>
\(w_i\) is the weight to assign to the function evaluation at the given point \(x_i\) </dd></dl>

</div>
</div>
<a class="anchor" id="a549a3320c54b0c3ed5226463bc718f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 3 &gt; SurgSim::Math::gaussQuadrature3Points</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;, &lt;x_3, w_3&gt;} </p>
<dl class="section note"><dt>Note</dt><dd>Gauss-Legendre quadrature numerically evaluates the integral of a function \(f\) with a finite sum using some weights and specific points of evaluation of the function \(f\): </dd>
<dd>
\(\int_{-1}^{+1} f(x) dx = \sum_{i=1}^n w_i f(x_i)\) </dd>
<dd>
n is the number of points used to discretized the integral </dd>
<dd>
\(x_i\) is the point to evaluate the function \(f\) with </dd>
<dd>
\(w_i\) is the weight to assign to the function evaluation at the given point \(x_i\) </dd></dl>

</div>
</div>
<a class="anchor" id="a06638bc0d2e6a9fae5c8aba928638e34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 4 &gt; SurgSim::Math::gaussQuadrature4Points</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>4-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;, &lt;x_3, w_3&gt;, &lt;x_4, w_4&gt;} </p>
<dl class="section note"><dt>Note</dt><dd>Gauss-Legendre quadrature numerically evaluates the integral of a function \(f\) with a finite sum using some weights and specific points of evaluation of the function \(f\): </dd>
<dd>
\(\int_{-1}^{+1} f(x) dx = \sum_{i=1}^n w_i f(x_i)\) </dd>
<dd>
n is the number of points used to discretized the integral </dd>
<dd>
\(x_i\) is the point to evaluate the function \(f\) with </dd>
<dd>
\(w_i\) is the weight to assign to the function evaluation at the given point \(x_i\) </dd></dl>

</div>
</div>
<a class="anchor" id="a226061422fe4dd21c4faf1887223be61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="structSurgSim_1_1Math_1_1gaussQuadraturePoint.html">gaussQuadraturePoint</a>, 5 &gt; SurgSim::Math::gaussQuadrature5Points</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>5-points Gauss-Legendre quadrature {&lt;x_1, w_1&gt;, &lt;x_2, w_2&gt;, &lt;x_3, w_3&gt;, &lt;x_4, w_4&gt;, &lt;x_5, w_5&gt;} </p>
<dl class="section note"><dt>Note</dt><dd>Gauss-Legendre quadrature numerically evaluates the integral of a function \(f\) with a finite sum using some weights and specific points of evaluation of the function \(f\): </dd>
<dd>
\(\int_{-1}^{+1} f(x) dx = \sum_{i=1}^n w_i f(x_i)\) </dd>
<dd>
n is the number of points used to discretized the integral </dd>
<dd>
\(x_i\) is the point to evaluate the function \(f\) with </dd>
<dd>
\(w_i\) is the weight to assign to the function evaluation at the given point \(x_i\) </dd></dl>

</div>
</div>
<a class="anchor" id="ae40bcb0b6821df71823c00e764a6a6e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;<a class="el" href="namespaceSurgSim_1_1Math.html#a9658a7cc17cc4b6f3d8accf2a8070125">IntegrationScheme</a>, std::string, std::hash&lt;int&gt; &gt; SurgSim::Math::IntegrationSchemeNames</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 26 2014 15:44:17 for OpenSurgSim by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
