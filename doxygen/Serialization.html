<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>OpenSurgSim: Serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 90px;">
  <td id="projectlogo">
     <img alt="OpenSurgSim: A free platform for open surgery simulation" src="OpenSurgSim-dox.png"/>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Serialization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Loading and storing of instances from the OpenSurgSim framework utilizes the facilities provided by YAML-cpp, the duck typing and introspection capabilities provided by <a class="el" href="classSurgSim_1_1Framework_1_1Accessible.html" title="Mixin class for enabling a property system on OSS classes, the instance still needs to initialize pro...">SurgSim::Framework::Accessible</a> and when necessary a generic class registration and factory mechanism provided by <a class="el" href="classSurgSim_1_1Framework_1_1ObjectFactory.html" title="An object factory, once a class is registered with the factory it can be used to create instances of ...">SurgSim::Framework::ObjectFactory</a>.</p>
<p>Together these classes enable a serialization solution that can load and store instances of classes without the need of knowing the structure.</p>
<p>By using YAML::Node, we can represent data in a form that can be written to file and read from a file in the <a class="el" href="namespaceYAML.html">YAML</a> format. By converting instances to and from YAML::Node we can enable the loading and storing of instances to disk. Depending on the requirements more or less work needs to be done to enable the conversions. We will describe the various steps in order of increasing complexity.</p>
<h2>Conventions</h2>
<p>For consistency we will agree on naming properties in CamelCase beginning with a capital letter, this concurs with the naming portion of the getter and setter. E.g. if a component has a public getter and setter getFileName() and setFileName() the property should be named 'FileName'. We reserve the names "ClassName", "Name" and "Uuid" for use in component serialization.</p>
<h2>POD</h2>
<p><a class="el" href="namespaceSurgSim.html">SurgSim</a> and YAML-cpp already include conversions from and to YAML::node for all the POD types that should be needed, int, float, double, std::map, std::vector, ... are handle, likewise with the main <a class="el" href="namespaceEigen.html">Eigen</a> classes Matrix and Vector. These can all be used with YAML::Node as such. </p><pre class="fragment">YAML::Node node;
node["value"] = 1;  
int a = node["value"].as&lt;int&gt;();
</pre><p>For more complex data types the conversion can be implemented as member functions, for consistency purposes the following signatures should be used: </p><pre class="fragment">YAML::node Class::encode();
void Class::decode(const YAML::Node&amp; node);
</pre><p>If an addition to the member class is not possible or the conversion using 'node.as&lt;&gt;()' is wished, it will be necessary to specialize the YAML::convert structure for the required class type that needs to be converted. </p><pre class="fragment">template &lt;&gt;
YAML::convert&lt;Class&gt;(...)
</pre><p>After implementing either of these it should be possible to create a node structure from the class under development, and to fill the members of the class with values from the node.</p>
<p>When restoring the class these approaches work best if the class that is being handled implements a default constructor, when it does the data in the given node does not have to be inspected or extracted before class creation. And a class can be filled with data as such. </p><pre class="fragment">Class a;
a.decode(dataNode);
</pre><p>When the constructor needs more data things like the following might become necessary possibly making the process more brittle </p><pre class="fragment">int val = node["val"].as&lt;int&gt;();
Class a(val);
a.decode(dataNode);
</pre><h2>Accessible</h2>
<p>An easy way to enable serialization for a class is to derive from <a class="el" href="classSurgSim_1_1Framework_1_1Accessible.html" title="Mixin class for enabling a property system on OSS classes, the instance still needs to initialize pro...">SurgSim::Framework::Accessible</a>, and to declare all the classes' properties that need to be serialized through the <code>SURGSIM_SERIALIZABLE_PROPERTY</code> macro. This macro does two things, it declares a read/write property on the instance, but it also declares a conversion from and to YAML::Node for this property. <code>Accessible</code> implements <code>encode()</code> and <code>decode()</code> in a way so that all the properties that were declared serializable can be serialized to and from the YAML::Node.</p>
<h2>ObjectFactory</h2>
<p>The above approaches work well when the type of the data that is being serialized is known, e.g. a list of objects of the same type, or the specific member variables of a class. An additional facility needs to be utilized when the objects that are being dealt with are of heterogeneous types, i.e. list of objects with same base type but different subtypes. In this case a factory class needs to be filled and utilized. The main purpose of the factory is to create an instance of a class from the name of the class. <code><a class="el" href="classSurgSim_1_1Framework_1_1ObjectFactory.html" title="An object factory, once a class is registered with the factory it can be used to create instances of ...">SurgSim::Framework::ObjectFactory</a></code> is one kind of factory class. For it to work correctly classes need to be registered with <code>ObjectFactory</code> through the <code>register&lt;Class&gt;()</code> template call. After register has been executed, you can create an instance of a class by calling <code>create("ClassName")</code> on the factory. Just by convention each class should indicate its name by using the 'ClassName' property or <code>getClassName()</code> member function.</p>
<h3>Registration</h3>
<p>For classes with limited subclasses it is usually pretty easy to execute all the calls to <code>register()</code> in one place, but sometimes this is not feasible and a more distributed approach is necessary. For Example when the classes are spread out over multiple libraries it can be hard to create an exhaustive list. In this case on can register the class through static initialisation using a macro. The following code used in the <code>.cpp</code> file can register a subclass in the superclasses factory if the superclass contains a factory. </p><pre class="fragment">namespace
{
     SURGSIM_REGISTER(BaseClass, DerivedClass)
}
</pre><p>with <code>Baseclass</code> being the fully qualified name of the base class e.g. <code><a class="el" href="classSurgSim_1_1Framework_1_1Component.html" title="Component is the main interface class to pass information to the system managers each will decide whe...">SurgSim::Framework::Component</a></code> and <code>Derived</code> the name of the derived class without name space e.g. <code>OsgBoxRepresentation</code>.</p>
<h3>Loading</h3>
<p>The key to restore the correct class under differing incoming classes is to implement the <a class="el" href="namespaceYAML.html">YAML</a> conversion specialized to the base class pointer, when the decode function is called, the decode code can determine at runtime what instance needs to be created and call the appropriate factory function. After the correct instance has been created, a class member <code>decode()</code> function can be used to fill the appropriate member variables.</p>
<h2>Instances vs. References</h2>
<p>When there is a need to load and store references to objects, when objects are being shared amongst other objects the serialization can be specialized to object instances and object pointers to indicate whether a reference to an object as opposed to the actual object data should be written. </p><pre class="fragment">template&lt;&gt;
YAML::convert&lt;Class&gt; ...

template&lt;&gt;
YAMLL::convert&lt;std::shared_ptr&lt;Class&gt;&gt;
</pre><p>In the calling code the determination needs to be made whether the reference is serialized or the actual instance. Only the instance serialization should write out the data, the reference serializations should write out, a unique identifier for the instance and class information, if needed. When reading the unique identifier can be used to return a pointer to the shared instance in all places where the object is being used. When the actual data is found the normal <code>decode()</code> can be used to restore the member data.</p>
<h2>Component Loading and Storing</h2>
<p>All of the above mechanisms are in place for loading and storing components. The component class implements a factory, it utilizes the split convert object to serialize shared component references from the inside of a component. The data for a component can be written out when the owning <code>SceneElement</code> writes its component. Additionally there is a registry data structure for components in the inside of the convert object that can be used to restore shared instances to components. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 26 2014 15:44:15 for OpenSurgSim by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
